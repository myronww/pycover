# Description
This repository contains information about the pycover.py script which is used to process gcov based code coverage results.

# File Format Descriptions
GCov utilizes two different file formats in the processing of code coverage information.  GCov uses a **Notes** file or **.gcno** file to record information about the branches, arcs and blocks that are associate with a source file and a **Data** file or **.gcda** file.  There is also a third file format **.info** file which is historically generated by **geninfo** and processed by **lcov** in order to be able to generate code coverage reports.

The **pycover.py** script can perform the function of geninfo and process data sources from varying locations in order to generate a **.info** file that combines all the information captured for a given code coverage run.  The **pycover.py** script can then also process the **.info** file in order to create HTML reports that show detailed information about the coverage associated with the captured code coverage data.

The following section describes the **.gcno** and **.gcda** that the **pycover.py** script consumes in order to generate the intermediate **.info** file and also describes the format of the **.info** file that it processes in order to create the HTML coverage report.

## Notes (.gcno) and Data (.gcda) Common File Format

### High Level Format
GCov outputs data as .gcda and .gcno files.  These files share a common overall file format.  The basic format of a gcov file consists of a single file header followed by a series of records like so:

```
[FileHeader] [Record] ... (up-to-end of file)
```

### File Header Description
The file header is made of three data items.

```
[magic] [version] [stamp]
```

The magic ident is different for the notes and the data files.  The magic ident can be used to determine the endianness of the file, when reading.  The version is the same for both files and is derived from gcc*s version number.  The stamp value is used to synchronize note and data files and to synchronize merging within with a data file.  It need not be an absolute time stamp, merely a ticker that increments fast enough and cycles slow enough to distinguish different compile/run/compile cycles.

Although the ident and version are formally 32 bit numbers, they are derived from 4 character ASCII strings.  The version number consists of the single character major version number, a two character minor version number (leading zero for versions less than 10) and a single character indicating the status of the release.  That will be **e** experimental, **p** pre-release and **r** for release.  Because, by good fortune, these are in alphabetical order, string collating can be used to compare version strings.  Be aware that the **e** designation will (naturally) be unstable and might be imcompatible with itself.  For gcc 3.4 experimental, it would be **304e** (0x33303465).  When the major version reaches 10, the letters A-Z will be used.  Assuming minor increments releases every 6 months, we have to make a major increment every 50 years.  Assuming major increments releases every 5 years, we*re ok for the next 155 years -- thats good enough for me also.


### Record Description
The records that follow the FileHeader vary in structure but can be enumerated using a structure of **Record Header** followed by **Record Buffer*

```
[Record Header] [Record Buffer]
```

Records are not nested, but there is a record hierarchy.   Tag numbers reflect this hierarchy.  Tags are unique across note and data files.  Records of a given type can vary in size depending on the amount of data they contain.

#### Logical Sections
The gcov files group some records together in logical sections.  A logical section has no formal struction in the file format itself, but is simplya grouping of records that are expected to follow each other in a sequence.  An example of a logical section is a **Function Graph** section in the GCNO files.

#### Record Header
The **Record Header** can be further broken apart as a **Tag** that indicates the type of record and a **Length** field which indicates the length of the buffer like so:

```
[Tag: UInt32] [Length: UInt32]
```
**Tag** - is a unsigned 32 bit integer that is descriptive of the type of record.  The tag value is split into 4 8-bit fields, one for each of four possible levels.  The most significant is allocated first.  Unused levels are zero.  Active levels are odd-valued, so that the LSB of the level is one.  A sub-level incorporates the values of its superlevels.  This formatting allows you to determine the tag hierarchy, without understanding the tags themselves, and is similar to the standard section numbering used in technical documents.

| Tag Values |    Category     |
|------------|-----------------|
| 1..3f      | Common Tags     |
| 41..9f     | Notes File Tags |
| a1..ff     | Data File Tags  |

**Length** - is a unsigned 32 bit integer that indicates the word length of the buffer that follows.  The word size is 4 bytes so a length of 5 would mean the buffer is 4 ** 5 bytes in size.

#### Record Buffer
The record buffer represents a collection of value fields the structure of which is determined by the type indicated in the header.

```
[Item] [Item] [Item] ... (up-to-end of buffer)
```
The record item fields can be either a UINT32 (32 bit unsigned integer), UINT64 (two 32 bit unsigned integer words), or a STRING (length, four byte aligned buffer)

#### Numerical Values
The numerical values in a GCOV file are recorded as 32 bit unsigned integers and use the endianness of the machine generating the file.

```
UInt32:   byte3 byte2 byte1 byte0  (big-endian)
UInt32:   byte0 byte1 byte2 byte3  (little-endian)
```

The 64 bit numbers are stored as two 32 bit integers, with the least significant 32 bit word stored first.

```
UInt64:  UInt32:low UInt32:high
```

#### String Values

## Notes (.gcda) Record Formats

```
[Unit] [Function Graph: SECTION] [Function Graph: SECTION] ... (up-to-end of file)
```

### Unit Record

```
[Checksum: UINT32] [Source: STRING]
```

### Function Graph Record

```
[Function Announcement] [Basic Blocks] [Arc Set (one per basic block)] [Line Set (zero or more to end-of-record)]
```

#### Function Announcement

#### Basic Blocks
The **Basic Blocks** record indicates the number of blocks thar are applicable to the previously announced function.  The record contains a series of **Flag** entries that are **UINT32** values that provide information about the corresponding blocks.  There is a one to one correspondence between the **Flag** entries and the number of blocks in a functions.  The **Basic Blocks** record is a good way to determine the number of blocks that apply to a function.  The record length is used to determine the number of flag entries.  A record length of 5 would mean there are 5 **Flag** entries that follow and thus 5 blocks associated with the function.

```
[Record Header: (tag, length)] [Flag: UInt32] ... (up-to-end of record)
```

#### Arc Set
There is exactly one **Arc Set** record for every basic block in a function.  The **Arc Set** records are not ordered for a given function but can be matched to a functions basic block using the **BlockNo** field.  The **BlockNo** field is a zero indexed value from 0 to (block count -1) that is the index of the block that the **Arc Set** information applies to.  The **Arc Set** record is an enumeration of the arcs that are applicable for blocks and the flags that apply for each block.

```
[Record Header: (tag, length)] [BlockNo: UInt32] [Arc] ... (up-to-end of record)
```

An **Arc** item consists of:

```
[DestBlock: UINT32] [Flags: UINT32]
```
GCOV code coverage is arc based coverage.  The arcs are used to construct a directed graph that depicts the possible program flow paths between the basic blocks that make up a function.  The basic blocks correspond to the nodes in the graph and the arcs correspond to the edges or paths between the nodes in the graph.

#### Line Set
The line set records prived an association between the basic blocks of a function and the lines of the source file that correspond to the basic blocks.  There is not necessarily a **Line Set** record for every basic block.  There are some implicit basic blocks in a **gcov** function graph that do not have corresponding **Line Set** entries.  There are three kinds of basic blocks that apply to every function graph and these are the (entry), (return), and (exit) blocks.  All calls to a function must pass through the (entry) block.  All paths out of a function that do not involve an exception go through the (return) block.  All exception based exit paths go to the exit block as well as the return block.
```
[Record Header: (tag, length)] [BlockNo: UInt32] [Line] ... (up-to-end of record)
```

```
[LineNo: UINT32 = 0] [Source: STRING]
[LineNo: UINT32 = (line number)] [Source: STRING (NULL)]
[LineNo: UINT32 = 0] [Source: STRING(NULL)]
```

## Data (.gcda) Record Formats

## Info (.info) File Format


# Function Graphs

![Directed Graph Legend](images/directed-graph-legend.gif)

## Simple Block

```cpp
int global_value = 0;

void graph_simpleblock()
{
    global_value = global_value + 1;
}
```

![Simple Block](images/simple-block.gif)

## Simple Branch

```cpp
int global_value = 0;

void graph_simplebranch(int taken)
{
    if (taken > 0)
    {
        global_value = global_value + 1;
    }
}
```
![Simple Branch](images/simple-branch.gif)

## Simple Call

```cpp
int global_value = 0;

void graph_simplecall()
{
    puts("Simple call block...");
}
```

![Simple Call](images/simple-call.gif)

## Mutliple Branches

```cpp
int global_value = 0;

void graph_multiplebranches(int pathSelect)
{
    if (pathSelect == 0)
    {
        global_value = global_value + 1;
    }
    else if (pathSelect == 1)
    {
        global_value = global_value + 2;
    }
    else
    {
        global_value = global_value + 3;
    }

    return;
}
```

![Multiple Branches](images/multiple-branches.gif)

## Mutliple Branches with Calls

```cpp
int global_value = 0;

void graph_multiplebranches_withcalls(int pathSelect)
{
    if (pathSelect == 0)
    {
        puts("Took path if...");
    }
    else if (pathSelect == 1)
    {
        puts("Took path else if...");
    }
    else
    {
        puts("Took path else...");
    }

    return;
}
```

![Multiple Branches with Calls](images/multiple-branches-with-calls.gif)


