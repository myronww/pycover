#!/usr/bin/python -Wignore
# Myron Walker , April 2012
"""
This file contains documentation about the GCC compiler and the code coverage file formats that were taken
from the 'filename' that is part of the GCC source.  I re-wrote the documentation some to attempt to clarify
some aspects of the file formats.  The GCC software is copywrited under the following terms.

    GCC is free software; you can redistribute it and/or modify it under
    the terms of the GNU General Public License as published by the Free
    Software Foundation; either version 2, or (at your option) any later
    version.
    
    File format for coverage information
    Copyright (C) 1996, 1997, 1998, 2000, 2002,
    2003, 2004, 2005 Free Software Foundation, Inc.
    Contributed by Bob Manson <manson@cygnus.com>.
    Completely remangled by Nathan Sidwell <nathan@codesourcery.com>.

    GCC is distributed in the hope that it will be useful, but WITHOUT ANY
    WARRANTY; without even the implied warranty of MERCHANTABILITY or
    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
    for more details.
    
    For more information about the GCC license see the file COPYING that is part of the GCC source distribution.
    
Coverage information is held in two files.  A notes file, which is generated by the compiler, and a data file, 
which is generated by the program under test.  Both files use a similar structure.  GCC does not attempt to make
these files backwards compatible with previous versions, as you only need coverage information when developing a
program.  The files hold version information, so that mismatches can be detected, and they use a format that allows
tools to skip information they do not understand or are not interested in.

Numbers are recorded in the 32 bit unsigned binary form of the endianness of the machine generating the file. 
64 bit numbers are stored as two 32 bit numbers, the low part first.  Strings are padded with 1 to 4 NUL bytes,
to bring the length up to a multiple of 4. The number of 4 bytes is stored, followed by the padded string. 
Zero length and NULL strings are simply stored as a length of zero (they have no trailing NUL or padding).

    uint32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3
    uint64:  uint32:low uint32:high
    string: uint32:0 | uint32:length char* char:0 padding
    padding: | char:0 | char:0 char:0 | char:0 char:0 char:0
    item: uint32 | uint64 | string

The basic format of the files is

    file : uint32:magic uint32:version uint32:stamp record*

The magic ident is different for the notes and the data files.  The magic ident is used to determine the endianness
of the file, when reading.  The version is the same for both files and is derived from gcc's version number. The
stamp value is used to synchronize note and data files and to synchronize merging within a data file. It need not 
be an absolute time stamp, merely a ticker that increments fast enough and cycles slow enough to distinguish
different compile/run/compile cycles.
   
Although the ident and version are formally 32 bit numbers, they are derived from 4 character ASCII strings.  The
version number consists of the single character major version number, a two character minor version number (leading
zero for versions less than 10), and a single character indicating the status of the release. That will be 'e' 
experimental, 'p' prerelease and 'r' for release. Because, by good fortune, these are in alphabetical order, string
collating can be used to compare version strings.  Be aware that the 'e' designation will (naturally) be unstable
and might be incompatible with itself.  For gcc 3.4 experimental, it would be '304e' (0x33303465).  When the major
version reaches 10, the letters A-Z will be used.  Assuming minor increments releases every 6 months, we have to
make a major increment every 50 years. Assuming major increments releases every 5 years, we're ok for the next
155 years -- good enough for me.

   A record has a tag, length and variable amount of data.

       record: header data
    header: uint32:tag uint32:length
    data: item*

Records are not nested, but there is a record hierarchy.  Tag numbers reflect this hierarchy.  Tags are unique
across note and data files.  Some record types have a varying amount of data.  The LENGTH is the number of 4bytes
that follow and is usually used to determine how much data.  The tag value is split into 4 8-bit fields, one for
each of four possible levels.  The most significant is allocated first.  Unused levels are zero.  Active levels are
odd-valued, so that the LSB of the level is one.  A sub-level incorporates the values of its superlevels.  This
formatting allows you to determine the tag hierarchy, without understanding the tags themselves, and is similar
to the standard section numbering used in technical documents.  Level values [1..3f] are used for common tags, 
values [41..9f] for the notes file and [a1..ff] for the data
file.

   The basic block graph file contains the following records
       note: unit function-graph*
          unit: header uint32:checksum string:source
          function-graph: announce_function basic_blocks {arcs | lines}*
              announce_function: header uint32:ident uint32:checksum string:name string:source int32:lineno
              basic_block: header uint32:flags*
          arcs: header uint32:block_no arc*
              arc:  uint32:dest_block uint32:flags
          lines: header uint32:block_no line*
               uint32:0 string:NULL
              line:  uint32:line_no | uint32:0 string:filename

The BASIC_BLOCK record holds per-bb flags.  The number of blocks can be inferred from its data length.  There is
one ARCS record per basic block.  The number of arcs from a bb is implicit from the data length.  It enumerates the 
destination bb and per-arc flags. There is one LINES record per basic block, it enumerates the source lines which 
belong to that basic block.  Source file names are introduced by a line number of 0, following lines are from the new
source file.  The initial source file for the function is NULL, but the current source file should be remembered from one
LINES record to the next.  The end of a block is indicated by an empty filename - this does not reset the current source
file.  Note there is no ordering of the ARCS and LINES records: they may be in any order, interleaved in any manner.
The current filename follows the order the LINES records are stored in the file, *not* the ordering of the blocks they
are for.

   The data file contains the following records.
        data: {unit function-data* summary:object summary:program*}*
    unit: header uint32:checksum

        function-data:    announce_function arc_counts
    announce_function: header uint32:ident uint32:checksum
    arc_counts: header int64:count*

    summary: uint32:checksum {count-summary} GCOV_COUNTERS
    count-summary:    uint32:num uint32:runs int64:sum
            int64:max int64:sum_max

The ANNOUNCE_FUNCTION record is the same as that in the note file, but without the source location.  The ARC_COUNTS 
gives the counter values for those arcs that are instrumented.  The SUMMARY records give information about the whole
object file and about the whole program.  The checksum is used for whole program summaries, and disambiguates different
programs which include the same instrumented object file.  There may be several program summaries, each with a unique
checksum.  The object summary's checksum is zero.  Note that the data file might contain information from several runs
concatenated, or the data might be merged.

This file is included by both the compiler, gcov tools and the runtime support library libgcov. IN_LIBGCOV and IN_GCOV
are used to distinguish which case is which.  If IN_LIBGCOV is nonzero, libgcov is being built. If IN_GCOV is nonzero,
the gcov tools are being built. Otherwise the compiler is being built. IN_GCOV may be positive or negative. If positive,
we are compiling a tool that requires additional functions (see the code for knowledge of what those functions are).



Following is a quick description of the tracefile  format  as  used  by genhtml, geninfo and lcov.

       A tracefile is made up of several human-readable lines of text, divided into sections. If available, a tracefile
       begins with the testname which is stored in the following format:

         TN:<test name>

       For each source file referenced in the .da file, there is a section containing filename and coverage data:

         SF:<absolute path to the source file>

       Following is a list of line numbers for each function name found in the source file:

         FN:<line number of function start>,<function name>

       Next, there is a list of execution counts for each instrumented function:

         FNDA:<execution count>,<function name>

       This list is followed by two lines containing the number of functions found and hit:

         FNF:<number of functions found>
         FNH:<number of function hit>

       Branch coverage information is stored which one line per branch:

         BRDA:<line number>,<block number>,<branch number>,<taken>

       Block number and branch number are gcc internal IDs for the branch.  Taken is either '-' if the basic block 
       containing the branch was never executed or a number indicating how often that branch was taken.

       Branch coverage summaries are stored in two lines:

         BRF:<number of branches found>
         BRH:<number of branches hit>

       Then there is a list of execution counts for each instrumented line (i.e. a line which resulted in executable code):

         DA:<line number>,<execution count>[,<checksum>]

       Note that there may be an optional checksum present for each instrumented line.  The current geninfo implementation
       uses an MD5 hash as check summing algorithm.

       At the end of a section, there is a summary about how many lines were found and how many were actually instrumented:

         LH:<number of lines with a non-zero execution count>
         LF:<number of instrumented lines>

       Each sections ends with:

         end_of_record

       In addition to the main source code file there are sections for all #included files which also contain executable code.

       Note that the absolute path of a source file is generated by interpreting  the  contents  of  the  respective .bb file
       (see gcov (1) for more information on this file type). Relative filenames  are  prefixed  with the directory in which the 
       .bb file is found.

       Note  also that symbolic links to the .bb file will be resolved so that the actual file path is used instead of the path
       to a link.  This approach  is  necessary  for  the mechanism to work with the /proc/gcov files.

"""

import base64
import operator
import os
import sys
import struct

from optparse import OptionGroup, OptionParser 
from optparse import OptParseError, BadOptionError, OptionError, OptionConflictError, OptionValueError

VERBOSE = True

def vprint(content=""):
    if VERBOSE:
        print(content)

# Base64 encoded PNGs to use when generating HTML reports code coverage 
class GenHTMLResources:
    AMBER_PNG =   "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAB3RJTUUH0gcRDygEmMvW4AAAAAlwSFlzAAALEgAACxIB0" + \
                  "t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURf/gUAAAAKJ62n4AAAAKSURBVHjaY2AAAAACAAHlJ978AAAAAElFTkSuQmCC"
    
    EMERALD_PNG = "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAB3RJTUUH0gcRDyIryfUDMwAAAAlwSFlzAAALEgAACxIB0" + \
                  "t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURRvqWQoKCg+6UIMAAAAKSURBVHjaY2AAAAACAAHlJ978AAAAAElFTkSuQmCC"
    
    RUBY_PNG =    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAB3RJTUUH0gcRDxgQXVc0bgAAAAlwSFlzAAALEgAACxIB0" + \
                  "t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURf81LwAAANAzmp0AAAAKSURBVHjaY2AAAAACAAHlJ978AAAAAElFTkSuQmCC"
    
    GLASS_PNG =   "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAABGdBTUEAALGPC/xhBQAAAAZQTFRF////AAAAVcLTfgAAA" + \
                  "AF0Uk5TAEDm2GYAAAABYktHRACIBR1IAAAACXBIWXMAAAsSAAALEgHS3X78AAAAB3RJTUUH0gcTDwgZxEBWEAAAAApJRE" + \
                  "FUeJxjYAAAAAIAAUivpHEAAAAASUVORK5CYII="
    
    SNOW_PNG =    "iVBORw0KGgoAAAANSUhEUgAAAAEAAAABAQMAAAAl21bKAAAAB3RJTUUH0gcRDx4ddbzvVQAAAAlwSFlzAAALEgAACxIB0" + \
                  "t1+/AAAAARnQU1BAACxjwv8YQUAAAAGUExURf///wAAAFXC034AAAAKSURBVHjaY2AAAAACAAHlJ978AAAAAElFTkSuQmCC"
    
    UPDOWN_PNG =  "iVBORw0KGgoAAAANSUhEUgAAAAoAAAAOCAYAAAAWo42rAAAAPElEQVQoz2NgQAP/oQBdnBFdEYokIyMjhkJspiArZsSnC" + \
                  "FkxIyFFMMDEMGCA+m4kPnhICnBiopCB2EQBAOlcL/XinQ/5AAAAAElFTkSuQmCC"
                  
    GCOV_CSS = """
/* All views: initial background and text color */
body
{
  color: #000000;
  background-color: #FFFFFF;
}

/* All views: standard link format*/
a:link
{
  color: #284FA8;
  text-decoration: underline;
}

/* All views: standard link - visited format */
a:visited
{
  color: #00CB40;
  text-decoration: underline;
}

/* All views: standard link - activated format */
a:active
{
  color: #FF0040;
  text-decoration: underline;
}

/* All views: main title format */
td.title
{
  text-align: center;
  padding-bottom: 10px;
  font-family: sans-serif;
  font-size: 20pt;
  font-style: italic;
  font-weight: bold;
}

/* All views: header item format */
td.headerItem
{
  text-align: right;
  padding-right: 6px;
  font-family: sans-serif;
  font-weight: bold;
  vertical-align: top;
  white-space: nowrap;
}

/* All views: header item value format */
td.headerValue
{
  text-align: left;
  color: #284FA8;
  font-family: sans-serif;
  font-weight: bold;
  white-space: nowrap;
}

/* All views: header item coverage table heading */
td.headerCovTableHead
{
  text-align: center;
  padding-right: 6px;
  padding-left: 6px;
  padding-bottom: 0px;
  font-family: sans-serif;
  font-size: 80%;
  white-space: nowrap;
}

/* All views: header item coverage table entry */
td.headerCovTableEntry
{
  text-align: right;
  color: #284FA8;
  font-family: sans-serif;
  font-weight: bold;
  white-space: nowrap;
  padding-left: 12px;
  padding-right: 4px;
  background-color: #DAE7FE;
}

/* All views: header item coverage table entry for high coverage rate */
td.headerCovTableEntryHi
{
  text-align: right;
  color: #000000;
  font-family: sans-serif;
  font-weight: bold;
  white-space: nowrap;
  padding-left: 12px;
  padding-right: 4px;
  background-color: #A7FC9D;
}

/* All views: header item coverage table entry for medium coverage rate */
td.headerCovTableEntryMed
{
  text-align: right;
  color: #000000;
  font-family: sans-serif;
  font-weight: bold;
  white-space: nowrap;
  padding-left: 12px;
  padding-right: 4px;
  background-color: #FFEA20;
}

/* All views: header item coverage table entry for ow coverage rate */
td.headerCovTableEntryLo
{
  text-align: right;
  color: #000000;
  font-family: sans-serif;
  font-weight: bold;
  white-space: nowrap;
  padding-left: 12px;
  padding-right: 4px;
  background-color: #FF0000;
}

/* All views: header legend value for legend entry */
td.headerValueLeg
{
  text-align: left;
  color: #000000;
  font-family: sans-serif;
  font-size: 80%;
  white-space: nowrap;
  padding-top: 4px;
}

/* All views: color of horizontal ruler */
td.ruler
{
  background-color: #6688D4;
}

/* All views: version string format */
td.versionInfo
{
  text-align: center;
  padding-top: 2px;
  font-family: sans-serif;
  font-style: italic;
}

/* Directory view/File view (all)/Test case descriptions:
   table headline format */
td.tableHead
{
  text-align: center;
  color: #FFFFFF;
  background-color: #6688D4;
  font-family: sans-serif;
  font-size: 120%;
  font-weight: bold;
  white-space: nowrap;
  padding-left: 4px;
  padding-right: 4px;
}

span.tableHeadSort
{
  padding-right: 4px;
}

/* Directory view/File view (all): filename entry format */
td.coverFile
{
  text-align: left;
  padding-left: 10px;
  padding-right: 20px; 
  color: #284FA8;
  background-color: #DAE7FE;
  font-family: monospace;
}

/* Directory view/File view (all): bar-graph entry format*/
td.coverBar
{
  padding-left: 10px;
  padding-right: 10px;
  background-color: #DAE7FE;
}

/* Directory view/File view (all): bar-graph outline color */
td.coverBarOutline
{
  background-color: #000000;
}

/* Directory view/File view (all): percentage entry for files with
   high coverage rate */
td.coverPerHi
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #A7FC9D;
  font-weight: bold;
  font-family: sans-serif;
}

/* Directory view/File view (all): line count entry for files with
   high coverage rate */
td.coverNumHi
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #A7FC9D;
  white-space: nowrap;
  font-family: sans-serif;
}

/* Directory view/File view (all): percentage entry for files with
   medium coverage rate */
td.coverPerMed
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #FFEA20;
  font-weight: bold;
  font-family: sans-serif;
}

/* Directory view/File view (all): line count entry for files with
   medium coverage rate */
td.coverNumMed
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #FFEA20;
  white-space: nowrap;
  font-family: sans-serif;
}

/* Directory view/File view (all): percentage entry for files with
   low coverage rate */
td.coverPerLo
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #FF0000;
  font-weight: bold;
  font-family: sans-serif;
}

/* Directory view/File view (all): line count entry for files with
   low coverage rate */
td.coverNumLo
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #FF0000;
  white-space: nowrap;
  font-family: sans-serif;
}

/* File view (all): "show/hide details" link format */
a.detail:link
{
  color: #B8D0FF;
  font-size:80%;
}

/* File view (all): "show/hide details" link - visited format */
a.detail:visited
{
  color: #B8D0FF;
  font-size:80%;
}

/* File view (all): "show/hide details" link - activated format */
a.detail:active
{
  color: #FFFFFF;
  font-size:80%;
}

/* File view (detail): test name entry */
td.testName
{
  text-align: right;
  padding-right: 10px;
  background-color: #DAE7FE;
  font-family: sans-serif;
}

/* File view (detail): test percentage entry */
td.testPer
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px; 
  background-color: #DAE7FE;
  font-family: sans-serif;
}

/* File view (detail): test lines count entry */
td.testNum
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px; 
  background-color: #DAE7FE;
  font-family: sans-serif;
}

/* Test case descriptions: test name format*/
dt
{
  font-family: sans-serif;
  font-weight: bold;
}

/* Test case descriptions: description table body */
td.testDescription
{
  padding-top: 10px;
  padding-left: 30px;
  padding-bottom: 10px;
  padding-right: 30px;
  background-color: #DAE7FE;
}

/* Source code view: function entry */
td.coverFn
{
  text-align: left;
  padding-left: 10px;
  padding-right: 20px; 
  color: #284FA8;
  background-color: #DAE7FE;
  font-family: monospace;
}

/* Source code view: function entry zero count*/
td.coverFnLo
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #FF0000;
  font-weight: bold;
  font-family: sans-serif;
}

/* Source code view: function entry nonzero count*/
td.coverFnHi
{
  text-align: right;
  padding-left: 10px;
  padding-right: 10px;
  background-color: #DAE7FE;
  font-weight: bold;
  font-family: sans-serif;
}

/* Source code view: source code format */
pre.source
{
  font-family: monospace;
  white-space: pre;
  margin-top: 2px;
}

/* Source code view: line number format */
span.lineNum
{
  background-color: #EFE383;
}

/* Source code view: format for lines which were executed */
td.lineCov,
span.lineCov
{
  background-color: #CAD7FE;
}

/* Source code view: format for Cov legend */
span.coverLegendCov
{
  padding-left: 10px;
  padding-right: 10px;
  padding-bottom: 2px;
  background-color: #CAD7FE;
}

/* Source code view: format for lines which were not executed */
td.lineNoCov,
span.lineNoCov
{
  background-color: #FF6230;
}

/* Source code view: format for NoCov legend */
span.coverLegendNoCov
{
  padding-left: 10px;
  padding-right: 10px;
  padding-bottom: 2px;
  background-color: #FF6230;
}

/* Source code view (function table): standard link - visited format */
td.lineNoCov > a:visited,
td.lineCov > a:visited
{  
  color: black;
  text-decoration: underline;
}  

/* Source code view: format for lines which were executed only in a
   previous version */
span.lineDiffCov
{
  background-color: #B5F7AF;
}

/* Source code view: format for branches which were executed
 * and taken */
span.branchCov
{
  background-color: #CAD7FE;
}

/* Source code view: format for branches which were executed
 * but not taken */
span.branchNoCov
{
  background-color: #FF6230;
}

/* Source code view: format for branches which were not executed */
span.branchNoExec
{
  background-color: #FF6230;
}

/* Source code view: format for the source code heading line */
pre.sourceHeading
{
  white-space: pre;
  font-family: monospace;
  font-weight: bold;
  margin: 0px;
}

/* All views: header legend value for low rate */
td.headerValueLegL
{
  font-family: sans-serif;
  text-align: center;
  white-space: nowrap;
  padding-left: 4px;
  padding-right: 2px;
  background-color: #FF0000;
  font-size: 80%;
}

/* All views: header legend value for med rate */
td.headerValueLegM
{
  font-family: sans-serif;
  text-align: center;
  white-space: nowrap;
  padding-left: 2px;
  padding-right: 2px;
  background-color: #FFEA20;
  font-size: 80%;
}

/* All views: header legend value for hi rate */
td.headerValueLegH
{
  font-family: sans-serif;
  text-align: center;
  white-space: nowrap;
  padding-left: 2px;
  padding-right: 4px;
  background-color: #A7FC9D;
  font-size: 80%;
}

/* All views except source code view: legend format for low coverage */
span.coverLegendCovLo
{
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 2px;
  background-color: #FF0000;
}

/* All views except source code view: legend format for med coverage */
span.coverLegendCovMed
{
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 2px;
  background-color: #FFEA20;
}

/* All views except source code view: legend format for hi coverage */
span.coverLegendCovHi
{
  padding-left: 10px;
  padding-right: 10px;
  padding-top: 2px;
  background-color: #A7FC9D;
}
"""
    
    @staticmethod
    def WriteCSS(folder, filename="gcov.css"):
        
        cssfile = open(filename, 'w')
        cssfile.write(GenHTMLResources.GCOV_CSS)
        cssfile.close()
        
        return
    
    @staticmethod
    def WritePNG(folder, filename, base64Buffer):
        
        pngfile = open(filename, 'w')
        pngbuffer = base64.b64decode(base64Buffer)
        pngfile.write(pngbuffer)
        pngfile.close()
        
        return
    
    @staticmethod
    def WritePNG_Amber(folder, filename="amber.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.AMBER_PNG)
        return
    
    @staticmethod
    def WritePNG_Emerald(folder, filename="emerald.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.EMERALD_PNG)
        return
    
    @staticmethod
    def WritePNG_Ruby(folder, filename="ruby.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.RUBY_PNG)
        return
    
    @staticmethod
    def WritePNG_Glass(folder, filename="glass.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.GLASS_PNG)
        return
    
    @staticmethod
    def WritePNG_Snow(folder, filename="snow.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.SNOW_PNG)
        return
    
    @staticmethod
    def WritePNG_UpDown(folder, filename="updown.png"):
        GenHTMLResources.WritePNG(folder, filename, GenHTMLResources.UPDOWN_PNG)
        return

class GCovInfoBranch:
    def __init__(self, lineno, blockno, branchno, taken=None):
        self.LineNumber = lineno
        self.BlockNumber = blockno
        self.BranchNumber = branchno
        self.TakenCounter = taken
    
    def IncrementTakenCount(self, incVal):
        if self.TakenCounter is None:
            self.TakenCounter = incVal
        else:
            self.TakenCounter = self.TakenCounter + incVal
        return

class GCovInfoFunction:
    def __init__(self, funcname, lineno, executionCount=0):
        self.FunctionName = funcname
        self.LineNumber = lineno
        self.ExecutionCount = executionCount
        
    def IncrementExecutionCount(self, incVal):
        self.ExecutionCount = self.ExecutionCount + incVal
        return

class GCovInfoLine:
    def __init__(self, lineno, executionCount=0, checkSum=None):
        self.LineNumber = lineno
        self.ExecutionCount = executionCount
        self.CheckSum = checkSum
    
    def IncrementExecutionCount(self, incVal):
        self.ExecutionCount = self.ExecutionCount + incVal
        return
    
    def SetCheckSum(self, checkSum):
        self.CheckSum = checkSum

class GCovInfoSourcefileWriter:
    def __init__(self, sourcefile, testname=None):
        self.TestName = ""
        self.Sourcefile = sourcefile
        self.BranchTraces = []
        self.FunctionTraces = []
        self.LineTraces = []
        
        if testname is not None:
            self.TestName = testname
        
        return
    
    def AddBranchTrace(self, lineno, blockno, branchno, taken=None):
        branchTrace = GCovInfoBranch(lineno, blockno, branchno, taken)
        self.BranchTraces.append(branchTrace)
        return branchTrace
    
    def AddFunctionTrace(self, funcname, lineno, executionCount=0):
        funcTrace = GCovInfoFunction(funcname, lineno, executionCount)
        self.FunctionTraces.append(funcTrace)
        
        return funcTrace
    
    def AddLineTrace(self, lineno, executionCount=0, checkSum=None):
        lineTrace = GCovInfoLine(lineno, executionCount, checkSum)
        self.LineTraces.append(lineTrace)
        return lineTrace
    
    def WriteTo(self, fileHandle):
        """
        """
        # --------------------------------------------------
        # Write out the Sourcefile name
        # --------------------------------------------------
        sourcefile = self.Sourcefile
        fileHandle.write("SF:%s\n" % sourcefile)
        
        # --------------------------------------------------
        # Write out the Function traces
        # --------------------------------------------------
        functionsCount = len(self.FunctionTraces)
        functionsHit = 0
        
        for ftrace in self.FunctionTraces:
            fileHandle.write("FN:%d,%s\n" % (ftrace.LineNumber, ftrace.FunctionName))
        
        for ftrace in self.FunctionTraces:
            if (ftrace.ExecutionCount > 0):
                functionsHit = functionsHit + 1
            fileHandle.write("FNDA:%d,%s\n" % (ftrace.ExecutionCount, ftrace.FunctionName))
        
        fileHandle.write("FNF:%d\n" % functionsCount)
        fileHandle.write("FNH:%d\n" % functionsHit)
        
        # --------------------------------------------------
        # Write out the Branch traces
        # --------------------------------------------------
        branchesCount = len(self.BranchTraces)
        branchesHit = 0
        
        if branchesCount > 0:
            for btrace in self.BranchTraces:
                if (btrace.TakenCounter is not None):
                    branchesHit = branchesHit + 1
                    fileHandle.write("BRDA:%d,%d,%d,%d\n" % (btrace.LineNumber, btrace.BlockNumber, btrace.BranchNumber, btrace.TakenCounter))
                else:
                    fileHandle.write("BRDA:%d,%d,%d,-\n" % (btrace.LineNumber, btrace.BlockNumber, btrace.BranchNumber))
            
            fileHandle.write("BRF:%d\n" % branchesCount)
            fileHandle.write("BRH:%d\n" % branchesHit)
        
        # --------------------------------------------------
        # Write out the Line traces
        # --------------------------------------------------
        linesCount = len(self.LineTraces)
        linesHit = 0
        
        if linesCount > 0:
            for ltrace in self.LineTraces:
                if ltrace.ExecutionCount > 0:
                    linesHit = linesHit + 1
                if ltrace.CheckSum is not None:
                    fileHandle.write("DA:%d,%d,%d\n" % (ltrace.LineNumber, ltrace.ExecutionCount, ltrace.CheckSum))
                else:
                    fileHandle.write("DA:%d,%d\n" % (ltrace.LineNumber, ltrace.ExecutionCount))
            
            fileHandle.write("LF:%d\n" % linesCount)
            fileHandle.write("LH:%d\n" % linesHit)
        
        # --------------------------------------------------
        # Write out the end of record marker
        # --------------------------------------------------
        fileHandle.write("end_of_record\n")
        
        return

class GCovInfoFileWriter:
    def __init__(self, traceFile, testname=None):
        """
            Valid 'testname' values consist of letters, numerical digits, and the underscore character.
        """
        self.TestName = ""
        self.TraceFile = traceFile
        
        if testname is not None:
            self.TestName = testname
        
        return
    
    @staticmethod
    def GetSortedKeys(coverageMapItem):
        sortedKeys = []
        
        keyLookupDictionary = {}
        
        funcGraphs = coverageMapItem.FunctionGraphs
        
        for fgraph in funcGraphs.values():
            origSrc = fgraph.OrigSource
            fullSrc = fgraph.Source
            
            keyLookupDictionary[origSrc] = fullSrc
        
        keyList = keyLookupDictionary.keys()
        keyList.sort()
        
        for okey in keyList:
            fkey = keyLookupDictionary[okey]
            sortedKeys.append(fkey)
        
        return sortedKeys
    
    TraceList = ["__sigbits",
                 "__sputc", 
                 "graph_loop_for",
                 "graph_nestedbranch_simple"]
    
    @staticmethod
    def TraceGraph(funcGraph, dumpinfo=False):
        
        funcName = funcGraph.Name
        
        if (GCovInfoFileWriter.TraceList is not None) and operator.contains(GCovInfoFileWriter.TraceList, funcName):
            dumpinfo = True
        
        if dumpinfo is not None:
            if dumpinfo:
                vprint ("")
                vprint ("Function (%s : %d): Solved=%s" % (funcGraph.Name, funcGraph.Ident, funcGraph.Solved))
                vprint ("+--------------------------------------------------------------------------------------------------------+")
                vprint ("")
                
                lastBlockIndex = len(funcGraph.Blocks)
                blockIndex = 0
                
                while blockIndex < lastBlockIndex:
                    block = funcGraph.Blocks[blockIndex]
                    
                    vprint ("    Block (%d): LineNo=%s Flags=%s IsBranchLanding=%s IsCallSite=%s IsExceptionLanding=%s IsReturnLanding=%s HasRelevantBranches=%s" % \
                        (blockIndex, block.LineNo, block.Flags, block.IsBranchLanding, block.IsCallSite, block.IsExceptionLanding, block.IsReturnLanding, block.HasRelevantBranches))
                    
                    vprint ("        PRED ARCS:")
                    
                    collectionLen = len(block.Arcs_Predecessors)
                    cindex = 0
                    
                    if collectionLen > 0:
                        while cindex < collectionLen:
                            arc = block.Arcs_Predecessors[cindex]
                            vprint ("            (%d) - DestBlockNo=%d Fake=%s FallThru=%s OnTree=%s IsRelevantBranch=%s IsExceptionBranch=%s" % \
                                    (cindex, arc.DestBlock, arc.HasFlagFake, arc.HasFlagFallThrough, arc.HasFlagOnTree, arc.IsRelevantBranch, arc.IsExceptionBranch))
                            cindex += 1
                    else:
                        vprint ("            (EMPTY)")
                    
                    vprint ("        SUCC ARCS:")
                    
                    collectionLen = len(block.Arcs_Successors)
                    cindex = 0
                    
                    if collectionLen > 0:
                        while cindex < collectionLen:
                            arc = block.Arcs_Successors[cindex]
                            vprint ("            (%d) - DestBlockNo=%d Fake=%s FallThru=%s OnTree=%s IsRelevantBranch=%s IsReturnBranch=%s IsExceptionBranch=%s" % \
                                    (cindex, arc.DestBlock, arc.HasFlagFake, arc.HasFlagFallThrough, arc.HasFlagOnTree, arc.IsRelevantBranch, arc.IsReturnBranch, arc.IsExceptionBranch))
                            cindex += 1
                    else:
                        vprint ("            (EMPTY)")
                    
                    vprint ("        LINES:")
                    
                    collectionLen = 0
                    if block.Lines is not None:
                        collectionLen = len(block.Lines)
                    else:
                        vprint ("            (EMPTY)")
                    
                    cindex = 0
                    
                    while(cindex < collectionLen):
                        line = block.Lines[cindex]
                        vprint ("            (%d) - %s" % (line.Number, line.Content))
                        cindex += 1
                    
                    vprint("")
                    
                    blockIndex += 1
                    #end while(blockIndex < lastBlockIndex)
                
                blockIndex = 0
                
                vprint ("|  BLOCK  |  ARC  |  COUNTER  |")
                
                while blockIndex < lastBlockIndex:
                    block = funcGraph.Blocks[blockIndex]
                    
                    
                    
                    
                    collectionLen = len(block.Arcs_Successors)
                    cindex = 0
                    
                    if collectionLen > 0:
                        while cindex < collectionLen:
                            arc = block.Arcs_Successors[cindex]
                            arcIndexStr = ("%d" % cindex).center(7)
                            if arc.Counter is None:
                                arcCounterStr = "     -     "
                            else:
                                arcCounterStr = ("%d" % arc.Counter).center(11)
                            if cindex == 0:
                                blkIndexStr = ("%d" % blockIndex).center(9)
                            else:
                                blkIndexStr = "         "
                            vprint ("|%s|%s|%s|" % (blkIndexStr, arcIndexStr, arcCounterStr))
                            cindex += 1
                    
                    blockIndex += 1
                    #end while(blockIndex < lastBlockIndex)
                    
                vprint ("")
                vprint ("+--------------------------------------------------------------------------------------------------------+")
                vprint ("")
                vprint ("")
            #end if dumpinfo:
            else:
                vprint ("Function (%s : %d): Solved=%s" % (funcGraph.Name, funcGraph.Ident, funcGraph.Solved))
        
        return
    
    def WriteSourcefileSection(self, coverageMapItem, testname=None):
        """
            Takes a coverage map item and writes a source file section to the output tracefile. 
        """
        
        sectionTestname = self.TestName
        if testname is not None:
            sectionTestname = testname
        
        sourcesMap = coverageMapItem.SourcesMap
        
        sourcesMapKeys = GCovInfoFileWriter.GetSortedKeys(coverageMapItem)
        
        writableFileCount = 0
        for sourcefile in sourcesMapKeys:
            if os.path.isabs(sourcefile):
                writableFileCount += 1
        
        if writableFileCount > 0:
            # --------------------------------------------------
            # Write out the Testcase name
            # --------------------------------------------------
            self.TraceFile.write("TN:%s\n" % self.TestName)
        
            for sourcefile in sourcesMapKeys:
                if not os.path.isabs(sourcefile):
                    continue
                
                sourceGraphs = sourcesMap[sourcefile]
                
                sourcefileWriter = GCovInfoSourcefileWriter(sourcefile, sectionTestname)
                
                for funcGraph in sourceGraphs.values():
                    
                    if funcGraph.Solved:
                        GCovInfoFileWriter.TraceGraph(funcGraph)
                        
                        sourcefileWriter.AddFunctionTrace(funcGraph.Name, funcGraph.LineNo, funcGraph.ExecutionCount)
                        
                        blockWithLinesCounter = 0
                        
                        lastBlockIndex = len(funcGraph.Blocks)
                        blockIndex = 0
                        relevantBlockIndex = 0
                        relevantBranchIndex = 0
                        
                        branchLineNo = None
                        
                        while(blockIndex < lastBlockIndex):
                            block = funcGraph.Blocks[blockIndex]
                            
                            hasLines = False
                            if (block.Lines is not None) and (len(block.Lines) > 0):
                                hasLines = True
                            
                            blockExecCount = 0
                            for arc in block.Arcs_Successors:
                                taken = arc.Counter
                                blockExecCount += taken
                            
                            if hasLines:
                                for line in block.Lines:
                                    lineNumber = line.Number
                                    if lineNumber > 0:
                                        branchLineNo = lineNumber
                                        checksum = None
                                        sourcefileWriter.AddLineTrace(line.Number, blockExecCount, checksum)
                                
                                relevantBlockIndex = 0
                                relevantBranchIndex = 0
                            
                            if block.HasRelevantBranches:
                                if block.IsCallSite:
                                    for arc in block.Arcs_Successors:
                                        if not arc.HasFlagFake:
                                            relevantBranchIndex += 1
                                else:
                                    for arc in block.Arcs_Successors:
                                        takenCounter = arc.Counter
                                        if blockExecCount > 0:
                                            sourcefileWriter.AddBranchTrace(branchLineNo, relevantBlockIndex, relevantBranchIndex, takenCounter)
                                        else:
                                            sourcefileWriter.AddBranchTrace(branchLineNo, relevantBlockIndex, relevantBranchIndex, None)
                                    
                                        relevantBranchIndex += 1
                                    relevantBlockIndex += 1
                            else:
                                if block.IsLoop:
                                    loopToBlockNo = None
                                    for arc in block.Arcs_Successors:
                                        if arc.DestBlock < blockIndex:
                                            loopToBlockNo = arc.DestBlock - 1
                                            break
                                    
                                    if loopToBlockNo is not None:
                                        loopToBlock = funcGraph.Blocks[loopToBlockNo]
                                        for line in loopToBlock.Lines:
                                            branchLineNo = line.Number
                                        for arc in block.Arcs_Successors:
                                            takenCounter = arc.Counter
                                            if blockExecCount > 0:
                                                sourcefileWriter.AddBranchTrace(branchLineNo, relevantBlockIndex, relevantBranchIndex, takenCounter)
                                            else:
                                                sourcefileWriter.AddBranchTrace(branchLineNo, relevantBlockIndex, relevantBranchIndex, None)
                                        
                                            relevantBranchIndex += 1
                                        relevantBlockIndex += 1
                                
                            blockIndex += 1
                            #end while(blockIndex < lastBlockIndex)
                    else:
                        GCovInfoFileWriter.TraceGraph(funcGraph, True)
                
                sourcefileWriter.WriteTo(self.TraceFile)
        
        return

GCOVIO_STRINGPADDING = ['\x00\x00\x00\x00', '\x00\x00\x00', '\x00\x00', '\x00']

class GCovIOConst:
    
    GCOV_VERSION_3_4_0    = 0x30400
    GCOV_VERSION_3_3_0    = 0x30300
    
    BBG_FILE_MAGIC    = 0x67626267    #gbbg
    GCNO_FILE_MAGIC   = 0x67636e6f    #gcno
    GCDA_FILE_MAGIC   = 0x67636461    #gcda
    
    GCNO_FILE_MAGIC_BIGENDIAN   = 0x6f6e6367    #oncg
    GCDA_FILE_MAGIC_BIGENDIAN   = 0x61646367    #adcg
    
    GCOV_TAG_FUNCTION         = 0x01000000
    GCOV_TAG_BLOCKS           = 0x01410000
    GCOV_TAG_ARCS             = 0x01430000
    GCOV_TAG_LINES            = 0x01450000
    GCOV_TAG_COUNTER_BASE     = 0x01a10000
    GCOV_TAG_OBJECT_SUMMARY   = 0xa1000000 # Obsolete
    GCOV_TAG_PROGRAM_SUMMARY  = 0xa3000000
    
    #GCNO_SOURCEFILE = 0x80000001
    #GCNO_FUNCTIONNAME = 0x80000002
    
    GCOVIO_TAGTYPE_STR = { GCOV_TAG_FUNCTION: "GCOV_TAG_FUNCTION", 
                           GCOV_TAG_BLOCKS: "GCOV_TAG_BLOCKS", 
                           GCOV_TAG_ARCS: "GCOV_TAG_ARCS", 
                           GCOV_TAG_LINES: "GCOV_TAG_LINES", 
                           GCOV_TAG_COUNTER_BASE: "GCOV_TAG_COUNTER_BASE", 
                           GCOV_TAG_OBJECT_SUMMARY: "GCOV_TAG_OBJECT_SUMMARY", 
                           GCOV_TAG_PROGRAM_SUMMARY: "GCOV_TAG_PROGRAM_SUMMARY" }
    
    PACKUINT32="=I"
    PACKUINT32_BIGENDIAN="=I"
    
    LOWORDERMASK =  0x00000000ffffffff
    HIGHORDERMASK = 0xffffffff00000000
    
    GCOV_FLAG_ARC_ON_TREE = 1
    GCOV_FLAG_ARC_FAKE = 2
    GCOV_FLAG_ARC_FALLTHROUGH = 4

class GCovIOFileHeader():
    """
        uint32:magic 
        uint32:version 
        uint32:stamp
    """
    def __init__(self, magic, version, stamp):
        self.Magic = magic
        self.Version = version
        self.Stamp = stamp
        return

class GCovIORecordHeader():
    """
        uint32:tag uint32:length
    """
    def __init__(self, tag, length):
        self.Tag = tag
        self.Length = length
        return

class GCovIORecord():
    """
        A gcov record consists of a header followed by a data buffer.  The head contains a 
        tag and length member.  The tag indicates the type of record and the length indicates
        the size of the buffer in 4 byte words.
        
             Record => [Header] [Buffer]
        
             Header => [UInt32: Tag] [UInt32: Length]
        
             Buffer => [Items]*
        
        The buffer in a gcov record is composed of items.  The items are grouped in various ways
        they are of three basic types.
        
             UInt32 (stored in the endieness of the host machine)
             UInt64 => [UInt32 (low)] [UInt32 (high)]
             String => [Length] [CharBuffer]
        
        Strings for a gcov record are padded using from 1 to 4 bytes of padding to ensure the 
        string length ends on a 32bit word boundry.  A null string is represented as a string with
        a length of 0 and no buffer and therefore no padding.
        
            NullString => [Length: 0]
    """
    def __init__(self, tag, length, itemsData):
        self.Header = GCovIORecordHeader(tag, length)
        self.ItemsData=itemsData
        return
    
    def __str__(self):
        tagKey = self.Header.Tag
        tagType = str(tagKey)
        if tagKey in GCovIOConst.GCOVIO_TAGTYPE_STR:
            tagType = GCovIOConst.GCOVIO_TAGTYPE_STR[tagKey]
        strval = "Type=%s Length=%d" % (tagType, self.Header.Length)
        return strval

class GCovIO():
    """
        FILE FORMAT:
        
        == Header ==
        [Magic] + [Version] + [Stamp] + [Records*]
        
        == Records ==
        [RecordHeader] + [RecordData]
        
        == RecordHeader ==
        [Tag(Int32)] + [Length(Int32)]
        
        Note: Length is the number of 4 byte words that are stored in the record
        
        == RecordData ==
        [Items*]
        
        == Items ==
            [Int32] | [Int64] | [String]
        
        UInt32: byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3
        UInt64: low (UInt32) high (UInt32)
        String: UInt32:0 | UInt32:length + char* char:0 padding
        
        Padding: '' | 'x00' | 'x00x00' | 'x00x00x00'
    """
    def __init__(self, filename=None, header=None, records=None):
        self.PackStr32 = GCovIOConst.PACKUINT32
        
        self.Filename = filename
        self.Header = header
        self.Records = records
        return
    
    def Load(self, filename=None, detectEndianess=True):
        if filename is not None:
            self.Filename = filename

        if self.Filename is None:
            raise IOError("GCovIO: Load 'Filename' not set")
        
        fileHandle = None
        
        try:
            fileHandle = open(self.Filename, 'r')
            
            fileSize = os.fstat(fileHandle.fileno()).st_size
            
            self.__LoadFileHeader(fileHandle, fileSize, detectEndianess)
            self.__LoadRecords(fileHandle, fileSize)
        finally:
            if fileHandle is not None:
                fileHandle.close()
        return
    
    def Save(self, filename=None):
        if filename is not None:
            self.Filename = filename
        
        if self.Filename is None:
            raise IOError("GCovIO: Save 'Filename' not set")
        
        try:
            fileHandle = open(self.Filename, 'w')
            
            self.__SaveHeader(fileHandle)
            self.__SaveRecords(fileHandle)
        finally:
            if fileHandle is not None:
                fileHandle.close()
        
        return
    
    def __LoadFileHeader(self, fileHandle, fileSize, detectEndianess):
        
        magic = GCovIO.ReadUInt32(fileHandle)
        
        if detectEndianess:
            if (magic == GCovIOConst.GCDA_FILE_MAGIC_BIGENDIAN) or \
               (magic == GCovIOConst.GCNO_FILE_MAGIC_BIGENDIAN):
                self.PackStr32 = GCovIOConst.PACKUINT32_BIGENDIAN
        
        version = GCovIO.ReadUInt32(fileHandle)
        stamp = GCovIO.ReadUInt32(fileHandle)
        
        self.Header = GCovIOFileHeader(magic, version, stamp)
        
        return
    
    def __LoadRecords(self, fileHandle, fileSize):
        
        self.Records = []
        
        curPos = fileHandle.tell()
        
        while (curPos < fileSize):
            
            bytesRemaining = fileSize - curPos
            if bytesRemaining < 8:
                vprint ("Reached the end of file without enough bytes remaining to read a complete record.")
                vprint ("filename=%s" % self.Filename)
                vprint ("bytesRemaining=%d" % bytesRemaining)
                
                extraBuffer = fileHandle.read(bytesRemaining)
                extraBytes = ""
                
                for byte in extraBuffer:
                    extraBytes += "0x%x " % (ord(byte))
                
                vprint ("extraBytes=%s" % extraBytes)
                
                break
            
            nxtRecord = GCovIO.ReadRecord(fileHandle)
            
            if nxtRecord is None:
                break
            
            self.Records.append(nxtRecord)
            
            curPos = fileHandle.tell()
        
        return
    
    def __SaveHeader(self, fileHandle):
        
        magic = self.Header.Magic
        version = self.Header.Version
        stamp = self.Header.Stamp
        
        GCovIO.WriteUInt32(fileHandle, magic)
        GCovIO.WriteUInt32(fileHandle, version)
        GCovIO.WriteUInt32(fileHandle, stamp)

        return
    
    def __SaveRecords(self, fileHandle):
        
        for record in self.Records:
            GCovIO.WriteRecord(fileHandle, record)
        
        return
    
    @staticmethod
    def ReadUInt32(fileHandle, packStr=GCovIOConst.PACKUINT32):
        """
            int32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3
        """
        quadByte = fileHandle.read(4)
        if len(quadByte) < 4:
            vprint ("ERROR: Problem reading Int32, not enough bytes left in record. quadByte=%s" % quadByte)
        
        val, = struct.unpack(packStr, quadByte)
        return val
    
    @staticmethod
    def ReadUInt64(fileHandle, packStr=GCovIOConst.PACKUINT32):
        """
            int64:  int32:low int32:high
        """
        lowOrder = GCovIO.ReadUInt32(fileHandle, packStr)
        highOrder = GCovIO.ReadUInt32(fileHandle, packStr)
        
        val = (highOrder << 32) | lowOrder
        
        return val
    
    @staticmethod
    def ReadString(fileHandle, packStr=GCovIOConst.PACKUINT32):
        """
            string: int32:0 | int32:length char* char:0 padding
            padding: | char:0 | char:0 char:0 | char:0 char:0 char:0
        """
        
        wordLength = GCovIO.ReadUInt32(fileHandle, packStr)
        strLen = wordLength * 4
        
        strVal = fileHandle.read(strLen)
        
        return strVal
    
    @staticmethod
    def ReadRecord(fileHandle, packStr=GCovIOConst.PACKUINT32):
        """
            record: header data
            header: int32:tag int32:length
              data: item*
        """
        recordTag = GCovIO.ReadUInt32(fileHandle, packStr)
        recordLength = GCovIO.ReadUInt32(fileHandle, packStr)
        
        byteLen = recordLength * 4
        recordItemsData = fileHandle.read(byteLen)
        
        return GCovIORecord(recordTag, recordLength, recordItemsData)
    
    @staticmethod
    def UnpackUInt32(buffer, pos, packStr=GCovIOConst.PACKUINT32):
        
        #Note: The comma is important because the return type from struct.unpack_from is a tuple
        val, = struct.unpack_from(packStr, buffer, pos)
        cpos = pos + 4
        return val, cpos
    
    @staticmethod
    def UnpackUInt64(buffer, pos, packStr=GCovIOConst.PACKUINT32):
        
        cpos = pos
        
        #Note: The comma is important because the return type from struct.unpack_from is a tuple
        lowOrder, = struct.unpack_from(packStr, buffer, cpos)
        cpos = cpos + 4
        
        highOrder, = struct.unpack_from(packStr, buffer, cpos)
        cpos = cpos + 4
        
        val = (highOrder << 32) | lowOrder
        
        return val, cpos
    
    @staticmethod
    def UnpackString(buffer, pos, packStr=GCovIOConst.PACKUINT32):
        
        #Note: The comma is important because the return type from struct.unpack_from is a tuple
        strWords, = struct.unpack_from(packStr, buffer, pos)
        cpos = pos + 4
        
        val = None
        
        if strWords > 0:
            strlen = strWords * 4
            strend = cpos + strlen
            
            buffSlice = buffer[cpos: strend]
            val = buffSlice.rstrip('\000')
            
            cpos = cpos + strlen
        
        return val, cpos
    
    @staticmethod
    def WriteUInt32(fileHandle, val, packStr=GCovIOConst.PACKUINT32):
        """
            int32:  byte3 byte2 byte1 byte0 | byte0 byte1 byte2 byte3
        """
        fileHandle.write(struct.pack(packStr, val))
        return
    
    @staticmethod
    def WriteUInt64(fileHandle, val, packStr=GCovIOConst.PACKUINT32):
        """
            int64:  int32:low int32:high
        """
        lowOrder = val &  GCovIOConst.LOWORDERMASK
        highOrder = (val & GCovIOConst.HIGHORDERMASK) >> 32
        
        # Write the low order word
        GCovIO.WriteUInt32(fileHandle, lowOrder)
        
        # Write the high order word
        GCovIO.WriteUInt32(fileHandle, highOrder)
        
        return
    
    @staticmethod
    def WriteString(fileHandle, val):
        """
            string: int32:0 | int32:length char* char:0 padding
            padding: | char:0 | char:0 char:0 | char:0 char:0 char:0
        """
        valLen = len(val)
        padlen = valLen % 4
        
        fileHandle.write(val)
        
        if (val[valLen - 1] == 'x00') and (padlen == 0):
            return
        
        fileHandle.write(GCOVIO_STRINGPADDING[padlen])
                
        return
    
    @staticmethod
    def WriteRecord(fileHandle, record):
        """
            record: header data
            header: int32:tag int32:length
              data: item*
        """
        recordTag = record.Tag
        GCovIO.WriteUInt32(fileHandle, recordTag)
        
        recordLength = record.Length
        GCovIO.WriteUInt32(fileHandle, recordLength)
        
        recordItemsData = record.ItemsData
        GCovIO.WriteUInt32(fileHandle, recordItemsData)
        
        return

class GCovCoverageMapItem:
    def __init__(self, dataLeaf, funcGraphs):
        self.DataLeaf = dataLeaf
        self.FunctionGraphs = {}
        self.SourcesMap = {}
        for fgraph in funcGraphs:
            self.FunctionGraphs.update({fgraph.Ident: fgraph})
            
            funcSource = fgraph.Source
            
            if funcSource in self.SourcesMap:
                srcFuncGraphDict = self.SourcesMap[funcSource]
                srcFuncGraphDict.update({fgraph.Ident: fgraph})
            else:
                srcFuncGraphDict = {fgraph.Ident: fgraph}
                self.SourcesMap.update({funcSource: srcFuncGraphDict})
        
        self.ObjectTraces = None
        self.ProgramTraces = None

class GCovTraceSummary:
    def __init__(self, funcTraces, objectTraces, programTraces):
        self.FuncTraces = funcTraces
        self.ObjectTraces = objectTraces
        self.ProgramTraces = programTraces

class GCovFunctionTrace:
    def __init__(self, ident, checksum, counters = None):
        self.Ident = ident
        self.CheckSum = checksum
        self.Counters = counters
        return
    
    def ApplyArcCounters(self, counters):
        self.Counters = counters
        return

class GCovDataCounterBaseRecord:
    """
    """
    def __init__(self, header, counters):
        self.Header = header
        self.Counters = counters

class GCovDataFunctionAnnouncementRecord():
    """
        header int32:ident int32:checksum
    """
    def __init__(self, header, ident, checksum):
        self.Header = header
        self.Ident = ident
        self.CheckSum = checksum
        return

class GCovDataObjectSummaryRecord():
    """"""
    def __init__(self, header, checksum, num, runs, sum, max, summax):
        self.Header = header
        self.CheckSum = checksum
        self.Num = num
        self.Runs = runs
        self.Sum = sum
        self.Max = max
        self.SumMax = summax
        return
    
class GCovDataProgramSummaryRecord():
    """"""
    def __init__(self, header, checksum, num, runs, sum, max, summax):
        self.Header = header
        self.CheckSum = checksum
        self.Num = num
        self.Runs = runs
        self.Sum = sum
        self.Max = max
        self.SumMax = summax
        return
    
class GCovDataFile(GCovIO):
    """
    The data file contains the following records.
    
    [TranslationUnit] [FunctionData]* [Summary:object] [Summary:program*]
    
        data: {unit function-data* summary:object summary:program*}*
    
    TranslationUnit: header int32:checksum
    
        function-data:    announce_function arc_counts
    announce_function: header int32:ident int32:checksum
    arc_counts: header int64:count*
    
    summary: int32:checksum {count-summary}GCOV_COUNTERS
    count-summary:    int32:num int32:runs int64:sum
            int64:max int64:sum_max
    """
    
    def __init__(self, filename=None):
        GCovIO.__init__(self, filename)
        
        self.__TraceSummary = None
        return
    
    def PullRecords(self):
        
        recordCount = len(self.Records)
        rindex = 0
        
        while rindex < recordCount:
            self.PullRecordAtIndex(rindex)
            rindex += 1
    
    def PullRecordAtIndex(self, index):
        if self.Records is None:
            raise LookupError("GCovNotesFile.PullRecord: You must call GCovDataFile.Load before attempting to pull a record.")
        
        recCount = len(self.Records)
        if index >= recCount:
            raise IndexError("GCovNotesFile.PullRecord: The specified index was out of range.")
        
        record = self.Records[index]
        if isinstance(record, GCovIORecord):
            cpos = 0
            buffer = record.ItemsData
            
            swapRecord = GCovDataFile.UnpackRecord(record, self.PackStr32)
            
            self.Records[index] = swapRecord
            del(record)
            record = swapRecord
        
        return record
    
    def CreateTraceSummary(self):
        
        if self.__TraceSummary is None:
            recordIndex = 0
            recordsLength = len(self.Records)
            
            functionTraces = []
            objectTraces = []
            programTraces = []
            
            currentTrace = None
            
            while(recordIndex < recordsLength):
                record = self.PullRecordAtIndex(recordIndex)
                
                tag = record.Header.Tag
                
                if tag == GCovIOConst.GCOV_TAG_FUNCTION:
                    if currentTrace is not None:
                        functionTraces.append(currentTrace)
                    currentTrace = GCovFunctionTrace(record.Ident, record.CheckSum)
                
                elif tag == GCovIOConst.GCOV_TAG_OBJECT_SUMMARY:
                    if currentTrace is not None:
                        functionTraces.append(currentTrace)
                    currentTrace = None
                    
                    objectTraces.append(record)
                
                elif tag == GCovIOConst.GCOV_TAG_PROGRAM_SUMMARY:
                    if currentTrace is not None:
                        functionTraces.append(currentTrace)
                    currentTrace = None
                    
                    programTraces.append(record)
                
                elif tag == GCovIOConst.GCOV_TAG_COUNTER_BASE:
                    currentTrace.ApplyArcCounters(record.Counters)
                else:
                    print("Skipping Unknown record type tag=0x%x" % tag)
                
                recordIndex += 1
                
            self.__TraceSummary = GCovTraceSummary(functionTraces, objectTraces, programTraces)
        
        return self.__TraceSummary
    
    @staticmethod
    def UnpackRecord(record, packStr=GCovIOConst.PACKUINT32):
        swapRecord = None
        cpos = 0
        
        tag = record.Header.Tag
        header = record.Header
        buffer = record.ItemsData
        
        if tag == GCovIOConst.GCOV_TAG_FUNCTION:
            swapRecord = GCovDataFile.UnpackFunctionAnnouncement(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_COUNTER_BASE:
            swapRecord = GCovDataFile.UnpackCounterBase(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_OBJECT_SUMMARY:
            swapRecord = GCovDataFile.UnpackObjectSummary(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_PROGRAM_SUMMARY:
            swapRecord = GCovDataFile.UnpackProgramSummary(header, buffer, cpos, packStr)
        else:
            raise IOError("Un-recognized tag (0x%x) found at record index in file." % (tag))
        
        return swapRecord
    
    @staticmethod
    def UnpackCounterBase(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
            announce_function: header int32:ident int32:checksum string:name string:source int32:lineno
        """
        cpos = pos
        
        counterLength = header.Length / 2
        counterIndex = 0
        
        counters = []
        
        while(counterIndex < counterLength):
            nextValue, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
            if nextValue == 386547056640:
                pass
            counters.append(nextValue)
            counterIndex += 1
        
        rval = GCovDataCounterBaseRecord (header, counters)
        
        return rval
    
    @staticmethod
    def UnpackFunctionAnnouncement(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
            announce_function: header int32:ident int32:checksum string:name string:source int32:lineno
        """
        cpos = pos
        
        ident, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        checksum, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        
        rval = GCovDataFunctionAnnouncementRecord(header, ident, checksum)
        
        return rval
    
    @staticmethod
    def UnpackObjectSummary(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
        """
        cpos = pos
        
        checksum, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        num, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        runs, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        sum, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        max, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        summax, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        
        rval = GCovDataObjectSummaryRecord(header, checksum, num, runs, sum, max, summax)
        
        return rval
    
    @staticmethod
    def UnpackProgramSummary(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
        """
        cpos = pos
        eob = len(buffer)
        
        checksum, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        num, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        runs, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        sum, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        max, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        summax, cpos = GCovIO.UnpackUInt64(buffer, cpos, packStr)
        
        rval = GCovDataProgramSummaryRecord(header, checksum, num, runs, sum, max, summax)
        
        return rval


class GCovGraphArc():
    """
        int32:dest_block int32:flags
    """
    def __init__(self, destBlock, flags):
        self.DestBlock = destBlock
        self.Flags = flags
        self.ArcId = None
        self.Counter = None
        
        self.HasFlagFake = ((flags & GCovIOConst.GCOV_FLAG_ARC_FAKE) > 0)
        self.HasFlagFallThrough = ((flags & GCovIOConst.GCOV_FLAG_ARC_FALLTHROUGH) > 0);
        self.HasFlagOnTree = ((flags & GCovIOConst.GCOV_FLAG_ARC_ON_TREE) > 0)
        
        self.IsRelevantBranch = False
        self.IsReturnBranch = False
        self.IsExceptionBranch = False
    
    def Print(self):
        print("        GCovGraphArc:")
        print("            DestBlock=%d" % self.DestBlock)
        print("            Flags=%d" % self.Flags)
        print("            ArcId=%d" % self.ArcId)
        print("            Counter=%d" % self.Counter)
        print("            HasFlagFake=%d" % self.HasFlagFake)
        print("            HasFlagFallThrough=%d" % self.HasFlagFallThrough)
        print("            HasFlagOnTree=%d" % self.HasFlagOnTree)
        print("            IsRelevantBranch=" + self.IsRelevantBranch)
        print("            IsExceptionBranch=" + self.IsExceptionBranch)
        
        return

class GCovGraphLine():
    """
        int32:line_no string:(filename | linestr | NULL)
    """
    def __init__(self, number, content):
        self.Number = number
        self.Content = content
    
    def Print(self):
        print("        GCovGraphLine:")
        print("            Number=%d" % self.Number)
        print("            Content=%s" % str(self.Content))
        return

class GCovGraphBlock():
    """
    """
    def __init__(self, blockNumber, flags):
        self.BlockNumber = blockNumber
        self.Flags = flags
        self.Lines = None
        self.LineNo = 0
        
        self.Arcs_Successors = []
        self.Arcs_Predecessors = []
        
        self.IsBranchLanding = False
        self.IsCallSite = False
        self.IsLoop = False
        self.IsExceptionLanding = False
        self.IsReturnLanding = False
        self.HasRelevantBranches = False
    
    def Print(self):
        print("    GCovGraphBlock (%d):" % self.BlockNumber)
        print("        Flags=%x" % self.Flags)
        print("        HasRelevantBranches=" + self.HasRelevantBranches)
        
        if self.Lines is not None:
            for line in self.Lines:
                line.Print()
            print("")
        
        return

class GCovGraphFunction():
    """
        note: unit function-graph*
          unit: header int32:checksum string:source
          function-graph: announce_function basic_blocks {arcs | lines}*
    """
    def __init__(self, functionAnnouncement):
        self.Ident = functionAnnouncement.Ident
        self.CheckSum = functionAnnouncement.CheckSum
        self.Name = functionAnnouncement.Name
        self.Source = functionAnnouncement.Source
        self.OrigSource = self.Source
        self.LineNo = functionAnnouncement.LineNo
        self.Blocks = None
        self.BlockCount = 0
        self.ExecutionCount = 0
        
        self.HasCatch = False
        
        self.Solved = False
        
        return
    
    def Print(self):
        print("===================================================================")
        print("GCovGraphFunction:")
        print("    Ident=%d" % self.Ident)
        print("    CheckSum=0x%x" % self.CheckSum)
        print("    Name=%s" % self.Name)
        print("    Source=%s" % self.Source)
        print("    LineNo=%d" % self.LineNo)
        print("")
        
        for blk in self.Blocks:
            blk.Print()
        
        print("===================================================================")
        print("")
    
    def ApplyArcSet(self, arcset, nextArcId):
        
        fromBlockNumber = arcset.BlockNumber
        
        fromBlock = self.Blocks[fromBlockNumber]
        fromBlock.Arcs_Successors = arcset.Arcs
        
        for arcTo in arcset.Arcs:
            arcTo.ArcId = nextArcId
            nextArcId += 1
            
            toBlockNumber = arcTo.DestBlock
            toBlock = self.Blocks[toBlockNumber]
            toBlock.Arcs_Predecessors.append(arcTo)
        
        return nextArcId
    
    def ApplyCounters(self, counters):
        counterIndex = 0
        for block in self.Blocks:
            for arc in block.Arcs_Successors:
                if (arc.Flags & GCovIOConst.GCOV_FLAG_ARC_FAKE) == 0 and \
                  (arc.Flags & GCovIOConst.GCOV_FLAG_ARC_ON_TREE) == 0:
                    if arc.Counter is None:
                        arc.Counter = 0
                    counterVal = counters[counterIndex]
                    arc.Counter += counterVal
                    counterIndex += 1
        
        if counterIndex != len(counters):
            print("WARNING: Not all of the counters were used.")
        
        return
    
    def ApplyLineSet(self, lineset):
        
        blockNumber = lineset.BlockNumber
        
        block = self.Blocks[blockNumber]
        block.Lines = lineset.Lines
        
        return
    
    def ApplyBasicBlock(self, basicBlock):
        
        blockNumber = 0
        blockCount = len(basicBlock.FlagSet)
        
        self.Blocks = []
        
        while(blockNumber < blockCount):
            blockFlags = basicBlock.FlagSet[blockNumber]
            
            block = GCovGraphBlock(blockNumber, blockFlags)
            self.Blocks.append(block)
            
            blockNumber += 1
        
        self.BlockCount = blockCount
        
        if self.BlockCount > 0:
            pass
        
        return
    
    def ResetCounters(self):
        counterIndex = 0
        for block in self.Blocks:
            for arc in block.Arcs_Successors:
                arc.Counter = None
        return
    
    def ResetUnknowns(self):
        counterIndex = 0
        for block in self.Blocks:
            for arc in block.Arcs_Successors:
                if (arc.Flags & GCovIOConst.GCOV_FLAG_ARC_FAKE) != 0 or \
                  (arc.Flags & GCovIOConst.GCOV_FLAG_ARC_ON_TREE) != 0:
                    arc.Counter = None
        return
    
    WALKSTATE_NONE = 0
    WALKSTATE_BRANCHCHAIN = 1
    
    WALKSTATE_STRINGS = ["WALKSTATE_NONE", "WALKSTATE_BRANCHCHAIN"]
    
    def SetPostProcessedFields(self):
        
        vprint ("Post Processing Graph for '%s'" % self.Name)
        
        if (self.Name == "__sputc"):
            pass
        
        blocksList = self.Blocks
        blocksLen = len(self.Blocks)
        
        lastBlockNo = blocksLen - 1
        lastBlock = blocksList[lastBlockNo]
        
        blockIndex = 0
        
        fakePredCount = 0
        for parc in lastBlock.Arcs_Predecessors:
            if parc.HasFlagFake:
                fakePredCount = fakePredCount + 1
        
        exceptionBlock = None
        exceptionBlockNo = None
        
        if fakePredCount >= (len(lastBlock.Arcs_Predecessors) - 1):
            exceptionBlock = lastBlock
            exceptionBlock.IsExceptionLanding = True
            exceptionBlockNo = lastBlockNo
        
        returnBlock = None
        returnBlockNo = None
        
        if fakePredCount == 0:
            returnBlock = lastBlock
            returnBlock.IsReturnLanding = True
            returnBlockNo = lastBlockNo
        else:
            returnBlockNo = lastBlockNo - 1
            returnBlock = blocksList[returnBlockNo]
            returnBlock.IsReturnLanding = True
        
        # -------------------------------------------------------------------------
        # Find and mark all the call site blocks and all the branches that are 
        # return branches
        # -------------------------------------------------------------------------
        while(blockIndex < blocksLen):
            nxtBlock = blocksList[blockIndex]
            
            succLen = len(nxtBlock.Arcs_Successors)
            predLen = len(nxtBlock.Arcs_Predecessors)
            
            setCallBranch = False
            
            for sarc in nxtBlock.Arcs_Successors:
                destBlockNo = sarc.DestBlock
                if sarc.HasFlagFake and (exceptionBlock is not None) and (destBlockNo == exceptionBlock.BlockNumber):
                    sarc.IsExceptionBranch = True
                    nxtBlock.IsCallSite = True
                    setCallBranch = True
                
                if sarc.DestBlock == returnBlockNo:
                    sarc.IsReturnBranch = True
            
            noFakePredArcs = True
            for parc in nxtBlock.Arcs_Predecessors:
                if parc.HasFlagFake:
                    noFakePredArcs = False
            
            if (predLen > 1) and noFakePredArcs:
                nxtBlock.IsBranchLanding = True
            
            blockIndex += 1
        
        # -------------------------------------------------------------------------
        # Find and mark all the blocks that have relevant branches
        # -------------------------------------------------------------------------
        blockIndex = 0
        
        walkStack = []
        walkState = GCovGraphFunction.WALKSTATE_NONE
        
        nxtBlock = None
        prevBlock = None
        
        while(blockIndex < blocksLen):
            prevBlock = nxtBlock
            nxtBlock = blocksList[blockIndex]
            
            vprint ("Block(%d) - %s" % (blockIndex, GCovGraphFunction.WALKSTATE_STRINGS[walkState]))
            
            hasLines = False
            if (nxtBlock.Lines is not None) and (len(nxtBlock.Lines) > 0):
                hasLines = True
            
            successorCount = len(nxtBlock.Arcs_Successors)
            
            #-------------------------------------------------------------------------------
            # This path is for processing sequences that began with a call-site
            #-------------------------------------------------------------------------------
            if walkState == GCovGraphFunction.WALKSTATE_BRANCHCHAIN:
                if hasLines or successorCount < 2:
                    if len(walkStack) > 0:
                        if not prevBlock.IsCallSite:
                            will_branch = len(prevBlock.Arcs_Successors) > 1
                            
                            if will_branch:
                                while(True):
                                    if len(walkStack) == 0:
                                        break
                                    
                                    sidx, sblk = walkStack.pop()
                                    
                                    sblk.HasRelevantBranches = True
                                    for arc in sblk.Arcs_Successors:
                                        arc.IsRelevantBranch = True
                                    #end while(True):
                        else:
                            while(True):
                                if len(walkStack) == 0:
                                    break
                                
                                sidx, sblk = walkStack.pop()
                                #end while(True):
                    walkStack = []
                    walkState = GCovGraphFunction.WALKSTATE_NONE
                else:
                    walkStack.append((blockIndex, nxtBlock))
            
            #-------------------------------------------------------------------------------
            # This path initiates the start of the processing of a decision chain
            #-------------------------------------------------------------------------------
            if walkState == GCovGraphFunction.WALKSTATE_NONE:
                #---------------------------------------------------------------------------------
                # If a block has lines and has more than one successor arc, it must be the start
                # of a relevant branch chain.
                #---------------------------------------------------------------------------------
                if hasLines:
                    if (successorCount > 1):
                            walkState = GCovGraphFunction.WALKSTATE_BRANCHCHAIN
                            walkStack.append((blockIndex, nxtBlock))
                    else:
                        walkState = GCovGraphFunction.WALKSTATE_NONE
                else:
                    if (successorCount > 1):
                        isloop = False
                        for arc in nxtBlock.Arcs_Successors:
                            if arc.DestBlock < blockIndex:
                                isloop = True
                        
                        if isloop:
                            nxtBlock.IsLoop = True
                    else:
                        walkState = GCovGraphFunction.WALKSTATE_NONE
            
            blockIndex += 1
        
        vprint ("")
        vprint ("")
        
        return
    
    def SolveGraph(self):
        """
                 Solves the function graph for the missing arc counts using the counts provided to ApplyCounters.  SolveGraph 
            requires that at least one call to ApplyCounters has been made with the correct counter data.  You can make reapeated
            calls to ApplyCounters to apply multiple counter data sets.  Then call SolveGraph to solve the graph.  To empty the
            graph counters use ResetCounters.
        """
        
        block = None
        
        #Next solve the graph for the unknown counters
        revisitList = []
        revisitList.extend(self.Blocks)
        
        lastRevisitCount = 0
        blocksToSolve = []
        
        while(True):
            
            if (len(blocksToSolve) == 0):
                revisitCount = len(revisitList)
                
                if (revisitCount > 0):
                    if (revisitCount == lastRevisitCount):
                        raise IndexError("ERROR: Unsolvable function graph.")
                    
                    lastRevisitCount = revisitCount
                    
                    blocksToSolve = revisitList
                    revisitList = []
                else:
                    break
            
            block = blocksToSolve.pop()
            
            predecessorUnknown = 0
            successorUnknown = 0
            
            predecessorCount = len(block.Arcs_Predecessors)
            successorCount = len(block.Arcs_Successors)
            
            for arc in block.Arcs_Predecessors:
                if arc.Counter is None:
                    predecessorUnknown += 1
            
            for arc in block.Arcs_Successors:
                if arc.Counter is None:
                    successorUnknown += 1
            
            # If a block has no predecessors or no successors we have to solve its arc counts from another block, no need to revisit
            if (predecessorCount == 0) or (successorCount == 0):
                pass
            
            # If a block has an unknown on both sides then put the block in the revisit list
            elif ((predecessorUnknown > 0) and (successorUnknown > 0)):
                revisitList.append(block)
            
            # If a block only has one unknown and it is an unknown predecessor then solve it here
            elif (predecessorUnknown == 1):
                succSum = 0
                for arc in block.Arcs_Successors:
                    succSum += arc.Counter
                
                predSum = 0
                
                unknownArc = None
                for arc in block.Arcs_Predecessors:
                    if arc.Counter is None:
                        unknownArc = arc
                    else:
                        predSum += arc.Counter
                
                unknownArc.Counter = succSum - predSum
            
            # If a block only has one unknown and it is an unknown successsor then solve it here
            elif successorUnknown == 1:
                predSum = 0
                for arc in block.Arcs_Predecessors:
                    predSum += arc.Counter
                
                succSum = 0
                
                unknownArc = None
                for arc in block.Arcs_Successors:
                    if arc.Counter is None:
                        unknownArc = arc
                    else:
                        succSum += arc.Counter
                
                unknownArc.Counter = predSum - succSum
                
            # Otherwise the block has two unsolved arcs on one side of the block, push it to the revisit list
            else:
                revisitList.append(block)
            
            #end while(True)
        blocksLen = len(self.Blocks)
        if blocksLen > 0:
            self.ExecutionCount = 0
            
            executionCount = 0
            
            entryBlock = self.Blocks[0]
            for arc in entryBlock.Arcs_Successors:
                arcCounter = arc.Counter
                executionCount += arcCounter
            
            self.ExecutionCount = executionCount
        
        self.Solved = True
        
        return sum
    
    @staticmethod
    def HasRelevantDescendantBlock_CallChain(blockList, blockListLen, block, blockIndex):
        
        isRelevant = False
        
        followOnBlock = None
        followOnBlockNo = None
        
        for sarc in block.Arcs_Successors:
            if not sarc.HasFlagFake:
                followOnBlockNo = sarc.DestBlock
                followOnBlock = blockList[followOnBlockNo]
        
        if (followOnBlock is not None):
            if followOnBlock.IsCallSite:
                if (followOnBlock.Lines is None) or (len(followOnBlock.Lines) == 0):
                    isRelevant = GCovGraphFunction.HasRelevantDescendantBlock_CallChain(blockList, blockListLen, followOnBlock, followOnBlockNo)
            else:
                if len(followOnBlock.Arcs_Successors) > 1:
                    isRelevant = True
            
            if isRelevant:
                followOnBlock.HasRelevantBranches = True
                for sarc in followOnBlock.Arcs_Successors:
                    sarc.IsRelevantBranch = True
        
        return isRelevant
    
    @staticmethod
    def HasRelevantDescendantBlock_Else(blockList, blockListLen, block, blockIndex):
        
        isRelevant = False
        
        followOnBlock = None
        followOnBlockNo = None
        
        for sarc in block.Arcs_Successors:
            if not sarc.HasFlagFake:
                followOnBlockNo = sarc.DestBlock
                followOnBlock = blockList[followOnBlockNo]
        
        if (followOnBlock is not None):
            if followOnBlock.IsCallSite:
                if (followOnBlock.Lines is None) or (len(followOnBlock.Lines) == 0):
                    isRelevant = GCovGraphFunction.HasRelevantDescendantBlock_CallChain(blockList, blockListLen, followOnBlock, followOnBlockNo)
            else:
                if len(followOnBlock.Arcs_Successors) > 1:
                    isRelevant = True
            
            if isRelevant:
                followOnBlock.HasRelevantBranches = True
                for sarc in followOnBlock.Arcs_Successors:
                    sarc.IsRelevantBranch = True
        
        return isRelevant

class GCovNotesArcSetRecord():
    """
        arcs: header int32:block_no arc*
    """
    def __init__(self, header, blockNumber, arcs):
        self.Header = header
        self.BlockNumber = blockNumber
        self.Arcs = arcs
    
    def Print(self):
        print("ArcsRecord: BlockNumber=%d" % self.BlockNumber)
        return

class GCovNotesLineSetRecord():
    """
        lines: header int32:block_no line* => termline
            line:  int32:line_no | int32:0 string:filename
            termline: int32:0 string:NULL
    """
    def __init__(self, header, blockNumber, lines):
        self.Header = header
        self.BlockNumber = blockNumber
        self.Lines = lines
    
    def Print(self):
        print("LinesRecord: BlockNumber=%d" % self.BlockNumber)
        return

class GCovNotesBasicBlocksRecord():
    def __init__(self, header, flagSet):
        self.Header = header
        self.FlagSet = flagSet
        return
    
    def Print(self):
        blockCount = len(self.FlagSet)
        print("BasicBlock: BlockCount=%d" % (blockCount))
        return

class GCovNotesFunctionAnnouncementRecord():
    """
        header int32:ident int32:checksum string:name string:source int32:lineno
    """
    def __init__(self, header, ident, checksum, name, source, lineno):
        self.Header = header
        self.Ident = ident
        self.CheckSum = checksum
        self.Name = name
        self.Source = source
        self.LineNo = lineno
        return
    
    def Print(self):
        print("Function: Ident=%d CheckSum=%d LineNo=%d Name=%s Source%s" % (self.Ident, self.CheckSum, self.LineNo, self.Name, self.Source))
        return

class GCovNotesFile(GCovIO):
    """
        The BASIC_BLOCK record holds per-bb flags.  The number of blocks
        can be inferred from its data length.  There is one ARCS record per
        basic block.  The number of arcs from a bb is implicit from the
        data length.  It enumerates the destination bb and per-arc flags.
        There is one LINES record per basic block, it enumerates the source
        lines which belong to that basic block.  Source file names are
        introduced by a line number of 0, following lines are from the new
        source file.  The initial source file for the function is NULL, but
        the current source file should be remembered from one LINES record
        to the next.  The end of a block is indicated by an empty filename
        - this does not reset the current source file.  Note there is no
        ordering of the ARCS and LINES records: they may be in any order,
        interleaved in any manner.  The current filename follows the order
        the LINES records are stored in the file, *not* the ordering of the
        blocks they are for.
        
    """
    
    def __init__(self, filename=None):
        GCovIO.__init__(self, filename)
        self.__Graphs = None
        return
    
    def PullRecords(self):
        
        recordCount = len(self.Records)
        rindex = 0
        
        while(rindex < recordCount):
            self.PullRecordAtIndex(rindex)
            rindex += 1
    
    def PullRecordAtIndex(self, index):
        if self.Records is None:
            raise LookupError("GCovNotesFile.PullRecord: You must call GCovDataFile.Load before attempting to pull a record.")
        
        recCount = len(self.Records)
        if index >= recCount:
            raise IndexError("GCovNotesFile.PullRecord: The specified index was out of range.")
        
        record = self.Records[index]
        if isinstance(record, GCovIORecord):
            cpos = 0
            buffer = record.ItemsData
            
            swapRecord = GCovNotesFile.UnpackRecord(record, self.PackStr32)
            
            self.Records[index] = swapRecord
            del(record)
            record = swapRecord
        
        return record
    
    def PullGraphs(self, refresh=False):
        
        if self.__Graphs is None or refresh == True:
            recordIndex = 0
            recordsLength = len(self.Records)
            
            functionGraphs = []
            currentGraph = None
            nextArcId = 0
            
            while(recordIndex < recordsLength):
                record = self.PullRecordAtIndex(recordIndex)
                
                tag = record.Header.Tag
                
                if tag == GCovIOConst.GCOV_TAG_FUNCTION:
                    nextArcId = 0
                    
                    currentGraph = GCovGraphFunction(record)
                    functionGraphs.append(currentGraph)
                    
                    vprint ("Processing function '%s' ident '%d'" % (currentGraph.Name, currentGraph.Ident))
                
                else:
                    if currentGraph is not None:
                        if tag == GCovIOConst.GCOV_TAG_BLOCKS:
                            currentGraph.ApplyBasicBlock(record)
                        elif tag == GCovIOConst.GCOV_TAG_ARCS:
                            nextArcId = currentGraph.ApplyArcSet(record, nextArcId)
                        elif tag == GCovIOConst.GCOV_TAG_LINES:
                            currentGraph.ApplyLineSet(record)
                        else:
                            print("WARNING: Skipping Unknown record type tag=0x%x" % tag)
                    else:
                        print("WARNING: Skipping un-announce function record of type tag=0x%x" % tag)
                        
                recordIndex += 1
            
            # Go through the function graphs and set the context inferred fields
            for currentGraph in functionGraphs:
                currentGraph.SetPostProcessedFields()
            
            self.__Graphs = functionGraphs
        
        return self.__Graphs
    
    @staticmethod
    def UnpackRecord(record, packStr=GCovIOConst.PACKUINT32):
        swapRecord = record
        cpos = 0
        
        tag = record.Header.Tag
        header = record.Header
        buffer = record.ItemsData
        
        if tag == GCovIOConst.GCOV_TAG_FUNCTION:
            swapRecord = GCovNotesFile.UnpackFunctionAnnouncement(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_ARCS:
            swapRecord = GCovNotesFile.UnpackArcSet(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_LINES:
            swapRecord = GCovNotesFile.UnpackLineSet(header, buffer, cpos, packStr)
        elif tag == GCovIOConst.GCOV_TAG_BLOCKS:
            swapRecord = GCovNotesFile.UnpackBasicBlock(header, buffer, cpos, packStr)
        else:
            raise IOError("Un-recognized tag (0x%x) found in file." % (tag))
        
        return swapRecord
    
    @staticmethod
    def UnpackArcSet(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
            arcs: header int32:block_no arc*
                arc:  int32:dest_block int32:flags
        """
        cpos = pos
        eob = len(buffer)
        
        blockNumber, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        
        arcCount = (eob - 4) / 8
        arcSet = []
        
        while arcCount > 0:
            destblock, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
            flags, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
            
            arcEntry = GCovGraphArc(destblock, flags)
            arcSet.append(arcEntry)
            
            arcCount -= 1
        
        rval = GCovNotesArcSetRecord(header, blockNumber, arcSet)
        
        return rval
    
    @staticmethod
    def UnpackBasicBlock(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
            header int32:flags*
        """
        cpos = pos
        eob = len(buffer)
        
        flagCount = header.Length
        flagSet = []
        while flagCount > 0:
            flags, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
            flagSet.append(flags)
            
            flagCount -= 1
        
        rval = GCovNotesBasicBlocksRecord(header, flagSet)
        
        return rval
    
    @staticmethod
    def UnpackFunctionAnnouncement(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
            announce_function: header int32:ident int32:checksum string:name string:source int32:lineno
        """
        cpos = pos
        
        ident, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        checksum, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        
        name, cpos = GCovIO.UnpackString(buffer, cpos, packStr)
        source, cpos = GCovIO.UnpackString(buffer, cpos, packStr)
        
        lineno, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        
        rval = GCovNotesFunctionAnnouncementRecord(header, ident, checksum, name, source, lineno)
        
        return rval
    
    @staticmethod
    def UnpackLineSet(header, buffer, pos, packStr=GCovIOConst.PACKUINT32):
        """
                lines: header int32:block_no line* => termline
            
            A unpacked line could look like any of the below items.  It is simply a int32 followed by a string
            
                line:  int32:0 string:filename
                       int32:line_no
                       int32:0, string:NULL
        """
        cpos = pos
        
        blockNumber, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
        
        lineset = []
        
        while True:
            lineno, cpos = GCovIO.UnpackUInt32(buffer, cpos, packStr)
            
            if lineno == 0:
                linestr, cpos = GCovIO.UnpackString(buffer, cpos, packStr)
            
            if (lineno == 0) and (linestr is None):
                break
            
            lineitem = GCovGraphLine(lineno, linestr)
            lineset.append(lineitem)
        
        rval = GCovNotesLineSetRecord(header, blockNumber, lineset)
        return rval

class GCovScanContext:
    IncludeFilters = []
    ExcludeFilters = []
    FilesFound = []
    
    def __init__(self, includeFilters, excludeFilters):
        self.IncludeFilters = includeFilters
        self.ExcludeFilters = excludeFilters

class GCovProcessor():
    __BasePathDataList = None
    __BasePathCodeList = None
    __BasePathGraphList = None
    __BasePathIncludeList = None
    
    __IncludeFilters = []
    __ExcludeFilters = []
    
    __CoverageMap = {}
    
    def __init__(self, basePathDataList = None, basePathGraphList=None, basePathCodeList=None, basePathIncludeList=None, includeFilter=None, excludeFilter=None):
        self.__BasePathDataList = basePathDataList
        self.__BasePathGraphList = basePathGraphList
        self.__BasePathCodeList = basePathCodeList
        self.__BasePathIncludeList = basePathIncludeList
        
        if includeFilter is not None:
            self.__IncludeFilters = includeFilter.split(':')
        
        if excludeFilter is not None:
            self.__ExcludeFilters = excludeFilter.split(':')
    
    def AddBasePathCode(self, path):
        if self.__BasePathCodeList is None:
            self.__BasePathCodeList = []
        
        self.__BasePathCodeList.append(path)
        
        return
    
    def AddBasePathData(self, path):
        if self.__BasePathDataList is None:
            self.__BasePathDataList = []
        
        self.__BasePathDataList.append(path)
        
        return
    
    def AddBasePathGraph(self, path):
        if self.__BasePathGraphList is None:
            self.__BasePathGraphList = []
        
        self.__BasePathGraphList.append(path)
        
        return
    
    def AddBasePathInclude(self, path):
        if self.__BasePathIncludeList is None:
            self.__BasePathIncludeList = []
        
        self.__BasePathIncludeList.append(path)
        
        return
    
    def GenerateTraceFile(self, traceFilename, testname=None):
        """
            TODO: Code the generate output method
        """
        
        traceFile = None
        
        try:
            traceFile = open(traceFilename, 'w')
            
            infoWriter = GCovInfoFileWriter(traceFile, testname)
            
            for coverageMapItem in self.__CoverageMap.values():
                infoWriter.WriteSourcefileSection(coverageMapItem)
        
        finally:
            if traceFile is not None:
                traceFile.close()
        
        return
    
    def PopulateCoverageMap(self, reset=True):
        
        if reset:
            self.Reset()
        
        for basePathData in self.__BasePathDataList:
            absBasePathData = os.path.abspath(basePathData)
            
            scanContext = GCovScanContext(self.__IncludeFilters, self.__ExcludeFilters)
            
            os.path.walk(absBasePathData, self.__Scan_For_DataFiles, scanContext)

            dataFileList = scanContext.FilesFound
            
            #Process all the data files
            for dataFilePath, dataFileName in dataFileList:
                self.__Process_DataFile(absBasePathData, dataFilePath, dataFileName)
            
            #Go through all of the coverage map items and resolve the unknown counts
            for key in self.__CoverageMap.keys():
                coverageitem = self.__CoverageMap[key]
                for funcGraph in coverageitem.FunctionGraphs.values():
                    try:
                        funcGraph.SolveGraph()
                    except:
                        pass
        
        return
    
    def Reset(self):
        
        for key in self.__CoverageMap.keys():
            item = self.__CoverageMap.pop(key)
            del(item)
        
        return
    
    def __Export_TraceFile(self, dataFileLeaf):
        """
            TODO: Continue implementing this method
        """
        df_leaf, df_ext = os.path.splitext(dataFileLeaf)
        
        #Open the .info file
        infoFilePath = os.path.join(self.__BasePathData, df_leaf + ".info")
        info_fh = None
        
        coverageMap = None
        
        try:
            info_fh = file(infoFilePath, 'w')
            
            #Go through the coverage map items and write the information to the info file
            for cmitem in coverageMap.Items:
                traceWriter = GCovInfoFileWriter("NA")
                
                traceWriter.WriteTo(info_fh)
        
        finally:
            if info_fh is not None:
                info_fh.close()
        
        return
    
    def __LocateGraphFile(self, df_fullbase, df_leafbase):
        foundfile = None
        
        if self.__BasePathGraphList is not None:
            for basePath in self.__BasePathGraphList:
                absBasePath = os.path.abspath(basePath)
                nxt_filename = os.path.join(absBasePath, df_leafbase + ".gcno")
                
                if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                    foundfile = nxt_filename
                    break
        else:
            nxt_filename = df_fullbase + ".gcno"
            
            if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                foundfile = nxt_filename
            
        return foundfile
    
    def __LocateSourceFile(self, df_fullbase, df_leafbase, c_file):
        foundfile = None
        
        if os.path.isabs(c_file) and os.path.exists(c_file) and os.path.isfile(c_file):
            foundfile = c_file
        else:
            c_dir = os.path.dirname(c_file)
            
            if c_dir != "":
                # If c_file has a relative path then do a search as follows:
                #    1. Look in the code path list by appending c_file to each path
                #    2. Look in the data path list by appending c_file to each path 
                if self.__BasePathCodeList is not None:
                    for basePath in self.__BasePathCodeList:
                        nxt_filename = os.path.join(basePath, c_file)
                        nxt_filename = os.path.abspath(nxt_filename)
                        
                        if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                            foundfile = nxt_filename
                            break
                
                if foundfile is None:
                    for basePath in self.__BasePathDataList:
                        nxt_filename = os.path.join(basePath, c_file)
                        nxt_filename = os.path.abspath(nxt_filename)
                        
                        if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                            foundfile = nxt_filename
                            break
            else:
                # If c_file is just a filename with no directory do a search as follows:
                #    1. Look in the code path list in the same leaf directory as the data file
                #    2. Look in the data path list in the same leaf directory as the data file
                #    3. Look in the include path list without appending the leaf of the data file
                df_dir = os.path.dirname(df_leafbase)
                
                chk_file = os.path.join(df_dir, c_file)
                
                if self.__BasePathCodeList is not None:
                    for basePath in self.__BasePathCodeList:
                        absBasePath = os.path.abspath(basePath)
                        nxt_filename = os.path.join(absBasePath, chk_file)
                        nxt_filename = os.path.abspath(nxt_filename)
                        
                        if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                            foundfile = nxt_filename
                            break
                
                if foundfile is None:
                    for basePath in self.__BasePathDataList:
                        absBasePath = os.path.abspath(basePath)
                        nxt_filename = os.path.join(absBasePath, chk_file)
                        nxt_filename = os.path.abspath(nxt_filename)
                        
                        if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                            foundfile = nxt_filename
                            break
                
                if (foundfile is None) and (self.__BasePathIncludeList is not None):
                    for basePath in self.__BasePathIncludeList:
                        absBasePath = os.path.abspath(basePath)
                        nxt_filename = os.path.join(absBasePath, c_file)
                        nxt_filename = os.path.abspath(nxt_filename)
                        
                        if os.path.exists(nxt_filename) and os.path.isfile(nxt_filename):
                            foundfile = nxt_filename
                            break
                        
        # Remove any base relative '/base/../../file' references from the path. 'os.path.isabs' still considers these absolute.
        if foundfile is not None:
            foundfile = os.path.abspath(foundfile)
        
        return foundfile
    
    def __Process_DataFile(self, basePathData, dataFileDir, dataFileName):
        
        #Break the dataFileLeaf path into its components
        df_base, df_ext = os.path.splitext(dataFileName)
        
        df_fullpathfile = os.path.join(dataFileDir, dataFileName)
        df_leafpathfile = df_fullpathfile[len(basePathData) + 1:]
        
        df_fullbasefile = os.path.join(dataFileDir, df_base)
        df_leafbasefile = df_fullbasefile[len(basePathData) + 1:]
        
        coverageItem = None
        
        if not self.__CoverageMap.has_key(df_leafpathfile):
            #Pull in the GCNO graph for the data file
            graphFilename = self.__LocateGraphFile(df_fullbasefile, df_leafbasefile)
            if graphFilename is not None:
                gf = GCovNotesFile(graphFilename)
                gf.Load()
                
                funcGraphs = gf.PullGraphs()
                
                #Go through the function graphs and locate the source files
                for fgraph in funcGraphs:
                    sourceFile = self.__LocateSourceFile(df_fullbasefile, df_leafbasefile, fgraph.Source)
                    if (sourceFile is not None) and os.path.exists(sourceFile):
                        fgraph.Source = sourceFile
                
                coverageItem = GCovCoverageMapItem(df_leafpathfile, funcGraphs)
                
                self.__CoverageMap[df_leafpathfile] = coverageItem
            else:
                #raise IOError("Could not locate gcno file for datafile=%s" % df_leafpathfile)
                print("Could not locate gcno file for datafile=%s" % df_leafpathfile)
        
        else:
            coverageItem = self.__CoverageMap[df_leafpathfile]
        
        if coverageItem is not None:
            #Process the data file and store the counters in coverage map
            df = GCovDataFile(df_fullpathfile)
            df.Load()
            
            traceSummary = df.CreateTraceSummary()
            
            functionGraphs = coverageItem.FunctionGraphs
            
            for funcTrace in traceSummary.FuncTraces:
                funcIdent = funcTrace.Ident
                
                if funcIdent in functionGraphs:
                    funcGraph = functionGraphs[funcIdent]
                    funcGraph.ApplyCounters(funcTrace.Counters)
                else:
                    print("Function Identity (%s) not found..." % funcIdent)
            
            coverageItem.ObjectTraces = traceSummary.ObjectTraces
            coverageItem.ProgramTraces = traceSummary.ProgramTraces
        
        return
    
    def __Scan_For_DataFiles(self, scanContext, currentDir, fileList):
        
        filesFound = scanContext.FilesFound
        
        for filename in fileList:
            f_base, f_ext = os.path.splitext(filename)
            if f_ext == ".gcda":
                filesFound.append((currentDir, filename))
        
        return True
    
    def __Scan_For_GraphFiles(self, scanContext, currentDir, fileList):
        
        filesFound = scanContext.FilesFound
        
        for filename in fileList:
            f_base, f_ext = os.path.splitext(filename)
            if f_ext == ".gcno":
                filesFound.append((currentDir, filename))
        
        return

def operation_capture(cmdOptions, cmdArgs):
    """
    """
    dataBasePathList = cmdOptions.DATAPATHS
    if (dataBasePathList is None) or (len(dataBasePathList) == 0):
        raise OptionError("You must specify at least one data source path to run a capture operation.")
    
    for chkpath in dataBasePathList:
        if not os.path.exists(chkpath):
            raise OptionError("The directory specified as the data path does not exist. path=%s" % chkpath)
    
    graphBasePathList = None
    if cmdOptions.GRAPHPATHS is not None:
        graphBasePathList = cmdOptions.GRAPHPATHS
        
        for chkpath in graphBasePathList:
            if not os.path.exists(chkpath):
                raise OptionError("The directory specified as the graph path does not exist. path=%s" % chkpath)
    
    sourceBasePathList = None
    if cmdOptions.SOURCEPATHS is not None:
        sourceBasePathList = cmdOptions.SOURCEPATHS
        
        for chkpath in sourceBasePathList:
            if not os.path.exists(chkpath):
                raise OptionError("The directory specified as the source code path does not exist. path=%s" % chkpath)
    
    includeFilter = "*"
    if cmdOptions.INCLUDEPATTERNS is not None:
        includeFilter = cmdOptions.INCLUDEPATTERNS
        
    excludeFilter = ""
    if cmdOptions.EXCLUDEPATTERNS is not None:
        includeFilter = cmdOptions.EXCLUDEPATTERNS
    
    if cmdOptions.OUTPUTFILE is None:
        raise OptionError("An output file must be specified for the --capture operation.")
    
    tracefileName = os.path.abspath(cmdOptions.OUTPUTFILE)
    
    #Make sure the parent directory of the output tracefile exists
    traceDir = os.path.dirname(tracefileName)
    if not os.path.exists(traceDir):
        os.makedirs(traceDir)
    
    gcov_proc = GCovProcessor(dataBasePathList, graphBasePathList, sourceBasePathList, None, includeFilter, excludeFilter)#
    
    gcov_proc.PopulateCoverageMap()
    
    gcov_proc.GenerateTraceFile(tracefileName)
    
    print("")
    print("Capture Completed...")
    
    return

def operation_merge(cmdOptions, cmdArgs):
    
    return

def operation_parse(cmdOptions, cmdArgs):
    if len(cmdArgs) <= 0:
        raise OptionError("The '--parse' option requires at least one gcov file as an arguement.")
    
    for parseFile in cmdArgs:
        
        fileRoot, fileExt = os.path.splitext(parseFile)
        filePath = os.path.abspath(parseFile)
        
        if fileExt == ".gcno":
            print("Processing .gcno file...")
            
            gcnoFile = GCovNotesFile()
            gcnoFile.Load(filePath)
            
            gcnoFile.PullRecords()
            
            for record in gcnoFile.Records:
                record.Print()
                
            graphSet = gcnoFile.PullGraphs()
            
            for graph in graphSet:
                graph.Print()
            
            print("")
            
        elif fileExt == ".gcda":
            print("Processing .gcda file...")
            
            gcdaFile = GCovDataFile()
            gcdaFile.Load(filePath)
            
            gcdaFile.PullRecords()
            
            for record in gcdaFile.Records:
                print(str(record))
        else:
            print("Unknown extension '%s'" % fileExt)
        
    return

def operation_remove(cmdOptions, cmdArgs):

    return

def operation_zerocounters(cmdOptions, cmdArgs):

    return

def validate_operation_count(cmdOptions, cmdArgs):
    # Make sure that at least one operation was specified
    operationCount = 0
    
    if cmdOptions.CAPTURE:
        operationCount += 1
    if cmdOptions.MERGE:
        operationCount += 1
    if cmdOptions.PARSE:
        operationCount += 1
    if cmdOptions.REMOVE is not None:
        operationCount += 1
    if cmdOptions.ZEROCOUNTERS:
        operationCount += 1
    
    if (operationCount == 0) or (operationCount > 1):
        raise OptionError("You must specify just one Operation option. operationCount=%d" % operationCount, "--parse")
    
    return

def validate_options(cmdOptions, cmdArgs):
    
    validate_operation_count(cmdOptions, cmdArgs)
    
    return

def pycover_main():
    
    print
    
    cmdUsage = "usage: %prog [options] arg1 arg2"
    
    optParser = OptionParser(cmdUsage)
    
    optGrpMisc = OptionGroup(optParser, "Miscellaneous")
    optGrpMisc.add_option("-v", "--version", dest="version", action="store_true", help="Prints out the version then exits.")
    optGrpMisc.add_option("-q", "--quiet", dest="verbose", action="store_false", help="Turn off verbose logging")
    optParser.add_option_group(optGrpMisc)
    
    optGrpOperations = OptionGroup(optParser, "Operations")
    optGrpOperations.add_option("-c", "--capture", dest="CAPTURE", action="store_true", help="Capture coverage data.")
    optGrpOperations.add_option("-m", "--merge", dest="MERGE", action="store_true", help="Merge all trace files into a single trace file.")
    optGrpOperations.add_option("-r", "--remove", dest="REMOVE", action="store_true", help="Remove traces from a trace file.")
    optGrpOperations.add_option("-z", "--zerocounters", dest="ZEROCOUNTERS", action="store_true", help="Reset all execution counts to zero.")
    optGrpOperations.add_option("--parse", dest="PARSE", action="store_true", help="Parse the specified file and print the contents to the console in a legible form.")
    optParser.add_option_group(optGrpOperations)
    
    optGrpOptions = OptionGroup(optParser, "Modifiers")
    optGrpOptions.add_option("-d", "--data-path", dest="DATAPATHS", action="append", help="Add path to a list of paths to scan for trace data files (.gcda files).")
    optGrpOptions.add_option("-s", "--source-path", dest="SOURCEPATHS", action="append", help="Add path to a list of paths to scan for source code files.")
    optGrpOptions.add_option("-g", "--graph-path", dest="GRAPHPATHS", action="append", help="Add path to a list of paths to scan for graph information files (.gcno files).")
    optGrpOptions.add_option("-x", "--extended-path", dest="EXTENDEDPATHS", action="append", help="Add path to a list of directories to scan for source files and header files.")
    optGrpOptions.add_option("-i", "--include-patterns", dest="INCLUDEPATTERNS", action="store", help="A semi-colon seperated list of patterns that are used while scanning for trace data files.")
    optGrpOptions.add_option("-e", "--exclude-patterns", dest="EXCLUDEPATTERNS", action="store", help="A semi-colon seperated list of patterns that are used while scanning for trace data files.")
    optGrpOptions.add_option("-o", "--output-file", dest="OUTPUTFILE", action="store", help="Write data to FILENAME instead of stdout.")
    
    optGrpOptions.add_option("--subtract", dest="SUBTRACTFILE", action="store", help="Subtract trace file.")
    optGrpOptions.add_option("--checksum", dest="LINECHECKSUM", action="store_true", help="Enable line check summing.")
    optGrpOptions.add_option("--no-checksum", dest="LINECHECKSUM", action="store_false", help="Disable line check summing.")
    optGrpOptions.add_option("--ignore-errors", dest="IGNOREERRORS", action="store_true", help="Continue after ERRORS (gcov, source, graph).")
    optGrpOptions.add_option("--no-recursion", dest="RECURSION", action="store_false", help="Exclude sub-directories from processing.")
    optGrpOptions.add_option("--no-markers", dest="EXCLUSIONMARKERS", action="store_false", help="Ignore exclusion markers in source code.")
    optGrpOptions.add_option("--derive-func-data", dest="GENFUNCDATA", action="store_true", help="Generate function data from line data.")
    optParser.add_option_group(optGrpOptions)
    
    try:
        
        (cmdOptions, cmdArgs) = optParser.parse_args()
        
        try:
            validate_options(cmdOptions, cmdArgs)
        
            if cmdOptions.CAPTURE:
                operation_capture(cmdOptions, cmdArgs)
            
            elif cmdOptions.MERGE:
                operation_merge(cmdOptions, cmdArgs)
            
            elif cmdOptions.PARSE:
                operation_parse(cmdOptions, cmdArgs)
            
            elif cmdOptions.REMOVE:
                operation_merge(cmdOptions, cmdArgs)
            
            elif cmdOptions.ZEROCOUNTERS:
                operation_zerocounters(cmdOptions, cmdArgs)
        except OptParseError as optError:
            print(str(optError))
            print("")
            
            optParser.print_help()
    
    except SystemExit:
        print("")
    
    return

if __name__ == "__main__":
    try:
        pycover_main()
    except:
        import traceback
        
        (exType, exValue, exTraceBack) = sys.exc_info()
        traceback.print_exception(exType, exValue, exTraceBack)
    pass

